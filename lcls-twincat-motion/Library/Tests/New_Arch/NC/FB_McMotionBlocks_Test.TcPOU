<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_McMotionBlocks_Test" Id="{dc41a27c-ab9f-47fb-bcb5-3fed2b1c906b}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_McMotionBlocks_Test EXTENDS FB_TestSuite
VAR
     fbAxisRef : ARRAY [1..8] OF AXIS_REF;
    fbLimSwStatus : ARRAY [1..8] OF FB_LimSwStatus_TestDouble;
    fbMotionLogger : ARRAY [1..8] OF FB_MotionLogger;

END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[GivenThatPowerIsEnabledAndMoveAbsoluteStartedAndCompletedThenMoveAbsoluteRetainsDoneStatus_Test1();
GivenThatPowerIsEnabledAndMoveAbsoluteStartedFollowByAHaltSignalThenMoveIsAbortedAndHaltDoneIsRetained_Test2();
GivenThatPowerIsEnabledAndMoveAbsoluteStartedFollowByAResetSignalThenMoveIsAbortedAndResetDoneIsRetained_Test3();
GivenThatDirectionalPositivePowerIsEnabledAndMoveAbsoluteStartedIfPositiveLimitHitThenMoveAbsoluteAbortedStatus_Test4();
GivenThatDirectionalNegativePowerIsEnabledAndMoveAbsoluteStartedIfNegativeLimitHitThenMoveAbsoluteAbortedStatus_Test5();
GivenHomeCmdBacklashCompensationInactiveThenMoveStartandCompletesWithBacklashCompensationDisabled_Test6();
GivenMoveCmdPositiveBacklashCompensationActiveThenReverseMoveStartedandCompletedWithBacklashCompensationEnabled_Test7();
]]></ST>
    </Implementation>
    <Method Name="GivenHomeCmdBacklashCompensationInactiveThenMoveStartandCompletesWithBacklashCompensationDisabled_Test6" Id="{d165f2d2-92b0-417e-9f05-e4578b84306f}">
      <Declaration><![CDATA[METHOD PRIVATE GivenHomeCmdBacklashCompensationInactiveThenMoveStartandCompletesWithBacklashCompensationDisabled_Test6
VAR_INST
    // Subject under tests
    fbBacklashCompensation : FB_BacklashCompensationNC(AxisRef := fbAxisRef[6]);

    // Backalsh is testing on simulated NC axis in Homing and PTP
    fbTestTimer : TON := (PT := T#5S, IN := TRUE);
    nTestStep : INT;
    fbHome : FB_HomeNC(AxisRef:=fbAxisRef[6], iLimSwStatus:=fbLimSwStatus[6],iMotionLogger:=fbMotionLogger[6]):=(Mode:=E_EpicsHomeCmd.HIGH_LIMIT);
    fbPower :  FB_PowerNC(AxisRef := fbAxisRef[6]);
    fbCamSwitchPulserSearch: TON := (IN:=TRUE, PT:=T#500MS);
    fbCamSwitchPulserSync: TON := (PT:=T#1000MS);
    bHomingOverride: BOOL := TRUE;
    bBacklashResetStatus : BOOL;
    bBacklashHomingStatus : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// must be called cycliclly
// one issue , directional enables mmust be overridden during homing.
fbPower.Power(	Enable := TRUE,
                  Enable_Positive := bHomingOverride OR fbLimSwStatus[6].LimForward,
                   Enable_Negative := bHomingOverride OR fbLimSwStatus[6].LimBackward,
                Override := 100
              );

CASE nTestStep OF
    0:
        fbBacklashCompensation.BacklashCompensationTest(UserEnable:=TRUE, Compensation:=1.0);
        nTestStep := nTestStep + 1;
    1:
        fbBacklashCompensation.BacklashCompensation(Enable:=FALSE, RampVelo:=10.0);
        bBacklashResetStatus := fbBacklashCompensation.Status;
        nTestStep := nTestStep + 1;
    2:

        IF  fbPower.PowerIsEnabled THEN
            // Initate Positive backlash compensation
            fbHome.Home(Position:=20.0,BufferMode:=MC_Aborting);
            nTestStep := nTestStep + 1;
        END_IF
    3:
        IF fbHome.Busy THEN
            bBacklashHomingStatus := fbBacklashCompensation.Status;
            nTestStep := nTestStep + 1;

        END_IF
    4:
        IF fbCamSwitchPulserSearch.Q THEN
            fbLimSwStatus[6].LimForward := FALSE;
            fbCamSwitchPulserSearch.IN := FALSE;
            fbCamSwitchPulserSync.IN := TRUE;
            nTestStep := nTestStep + 1;
        END_IF
    5:
        IF fbCamSwitchPulserSync.Q THEN
            fbLimSwStatus[6].LimForward := TRUE;
            nTestStep := nTestStep + 1;
        END_IF
    6:
        IF fbHome.Done THEN

            nTestStep := nTestStep + 1;
        END_IF
    7:;

END_CASE
//
fbAxisRef[6].ReadStatus();
fbBacklashCompensation();
fbHome();
fbCamSwitchPulserSearch();
fbCamSwitchPulserSync();
fbTestTimer();

IF nTestStep = 7 THEN
    AssertFalse(Condition :=  bBacklashHomingStatus, Message := 'backlash  must be disabled while homing #1');
    AssertFalse(Condition := bBacklashResetStatus, Message := 'backlash must be disabled after resetting #2');
    AssertTrue(Condition :=  ((fbAxisRef[6].NcToPlc.ActPos - fbAxisRef[6].NcToPlc.ActPosWithoutPosCorrection)= 0),
                                 Message := 'backlash compensation must be enable #3');
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );

    TEST_FINISHED();
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenMoveCmdNegativeBacklashCompensationActiveThenReverseMoveStartedandCompletedWithBacklashCompensationEnabled_Test8" Id="{ed4242b5-1f08-417f-b32f-5a900afbf462}">
      <Declaration><![CDATA[METHOD PRIVATE GivenMoveCmdNegativeBacklashCompensationActiveThenReverseMoveStartedandCompletedWithBacklashCompensationEnabled_Test8
VAR_INST
    // Subject under tests
    fbBacklashCompensation : FB_BacklashCompensationNC(AxisRef := fbAxisRef[8]);

    // Backalsh is testing on simulated NC axis in Homing and PTP
    fbTestTimer : TON := (PT := T#5S, IN := TRUE);
    nTestStep : INT;

    fbMoveAbsolute : FB_MoveAbsoluteNC(AxisRef := fbAxisRef[8]);
    fbPower :  FB_PowerNC(AxisRef := fbAxisRef[8]);
    bBacklashResetStatus : BOOL;
    bBacklashStatus : BOOL;
    fNoCompensation : LREAL;
    fCompensation : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// must be called cycliclly
// one issue , directional enables mmust be overridden during homing.
fbPower.Power(	Enable := TRUE,
                  Enable_Positive := fbLimSwStatus[8].LimForward,
                   Enable_Negative := fbLimSwStatus[8].LimBackward,
                Override := 100
              );

CASE nTestStep OF
    0:
        fbBacklashCompensation.BacklashCompensationTest(UserEnable:=TRUE, Compensation:=-4.0);
        nTestStep := nTestStep + 1;
    1:
        bBacklashResetStatus := fbBacklashCompensation.Status;
        fbBacklashCompensation.BacklashCompensation(Enable:=TRUE, RampVelo:=10.0);
        nTestStep := nTestStep + 1;

    2:

        bBacklashStatus := fbBacklashCompensation.Status;
        IF  fbPower.PowerIsEnabled THEN
            // Initate Positive backlash compensation
            fbMoveAbsolute.MoveAbsolute(	Position := -150.0,
                                            Velocity := 100,
                                            Acceleration := 200,
                                            Deceleration := 200
                                        );
            nTestStep := nTestStep + 1;
        END_IF
    3:
         IF fbMoveAbsolute.Done THEN
            fNoCompensation := (fbAxisRef[8].NcToPlc.ActPos - fbAxisRef[8].NcToPlc.ActPosWithoutPosCorrection);

            nTestStep := nTestStep + 1;
        END_IF
    4:
        // reverse movement
        fbMoveAbsolute.MoveAbsolute(	Position := 100.0,
                                           Velocity := 100,
                                          Acceleration := 200,
                                         Deceleration := 200
                                    );
        nTestStep := nTestStep + 1;
    5:
         IF fbMoveAbsolute.Done THEN
            fCompensation :=(fbAxisRef[8].NcToPlc.ActPos - fbAxisRef[8].NcToPlc.ActPosWithoutPosCorrection);
            nTestStep := nTestStep + 1;
        END_IF

END_CASE
//
fbAxisRef[8].ReadStatus();
fbBacklashCompensation();
fbMoveAbsolute();
fbTestTimer();

IF nTestStep = 6 THEN
    AssertFalse(Condition :=  bBacklashResetStatus, Message := 'backlash compensation must be disabled after resetting #1');
    AssertTrue(Condition :=  bBacklashStatus, Message := 'backlash compensation must be enable #2');
    AssertTrue(Condition :=  (fNoCompensation= 0),Message := 'No Backlash compensation in this direction #3');
    AssertTrue(Condition :=  (fCompensation= 4),Message := 'Current backlash must be 4 #4');
    AssertTrue(Condition :=  fbBacklashCompensation.status, Message := 'backlash compensation must stay enable after absolute move #5');
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );

    TEST_FINISHED();
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenMoveCmdPositiveBacklashCompensationActiveThenReverseMoveStartedandCompletedWithBacklashCompensationEnabled_Test7" Id="{9c1a4bce-ba95-4b9d-bd69-46b6e3327f0a}">
      <Declaration><![CDATA[METHOD PRIVATE GivenMoveCmdPositiveBacklashCompensationActiveThenReverseMoveStartedandCompletedWithBacklashCompensationEnabled_Test7
VAR_INST
    // Subject under tests
    fbBacklashCompensation : FB_BacklashCompensationNC(AxisRef := fbAxisRef[7]);

    // Backalsh is testing on simulated NC axis in Homing and PTP
    fbTestTimer : TON := (PT := T#5S, IN := TRUE);
    nTestStep : INT;

    fbMoveAbsolute : FB_MoveAbsoluteNC(AxisRef := fbAxisRef[7]);
    fbPower :  FB_PowerNC(AxisRef := fbAxisRef[7]);
    bBacklashResetStatus : BOOL;
    bBacklashStatus : BOOL;
    fNoCompensation : LREAL;
    fCompensation : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// must be called cycliclly
// one issue , directional enables mmust be overridden during homing.
fbPower.Power(	Enable := TRUE,
                  Enable_Positive := fbLimSwStatus[7].LimForward,
                   Enable_Negative := fbLimSwStatus[7].LimBackward,
                Override := 100
              );

CASE nTestStep OF
    0:
        fbBacklashCompensation.BacklashCompensationTest(UserEnable:=TRUE, Compensation:=1.0);
        nTestStep := nTestStep + 1;
    1:
        bBacklashResetStatus := fbBacklashCompensation.Status;
        fbBacklashCompensation.BacklashCompensation(Enable:=TRUE, RampVelo:=10.0);
        nTestStep := nTestStep + 1;

    2:

        bBacklashStatus := fbBacklashCompensation.Status;
        IF  fbPower.PowerIsEnabled THEN
            // Initate Positive backlash compensation
            fbMoveAbsolute.MoveAbsolute(	Position := 150.0,
                                            Velocity := 100,
                                            Acceleration := 200,
                                            Deceleration := 200
                                        );
            nTestStep := nTestStep + 1;
        END_IF
    3:
         IF fbMoveAbsolute.Done THEN
            fNoCompensation := (fbAxisRef[7].NcToPlc.ActPos - fbAxisRef[7].NcToPlc.ActPosWithoutPosCorrection);

            nTestStep := nTestStep + 1;
        END_IF
    4:
        // reverse movement
        fbMoveAbsolute.MoveAbsolute(	Position := 100.0,
                                           Velocity := 100,
                                          Acceleration := 200,
                                         Deceleration := 200
                                    );
        nTestStep := nTestStep + 1;
    5:
         IF fbMoveAbsolute.Done THEN
            fCompensation :=(fbAxisRef[7].NcToPlc.ActPos - fbAxisRef[7].NcToPlc.ActPosWithoutPosCorrection);
            nTestStep := nTestStep + 1;
        END_IF

END_CASE
//
fbAxisRef[7].ReadStatus();
fbBacklashCompensation();
fbMoveAbsolute();
fbTestTimer();

IF nTestStep = 6 THEN
    AssertFalse(Condition :=  bBacklashResetStatus, Message := 'backlash compensation must be disabled after resetting #1');
    AssertTrue(Condition :=  bBacklashStatus, Message := 'backlash compensation must be enable #2');
    AssertTrue(Condition :=  (fNoCompensation= 0),Message := 'No Backlash compensation in this direction #3');
    AssertTrue(Condition :=  (fCompensation= 1),Message := 'Current backlash must be 1 #4');
    AssertTrue(Condition :=  fbBacklashCompensation.status, Message := 'backlash compensation must stay enable after absolute move #5');
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStep))
    );

    TEST_FINISHED();
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenThatDirectionalNegativePowerIsEnabledAndMoveAbsoluteStartedIfNegativeLimitHitThenMoveAbsoluteAbortedStatus_Test5" Id="{2b29e441-0e05-443a-bf4f-6018918ec3e3}">
      <Declaration><![CDATA[METHOD PRIVATE GivenThatDirectionalNegativePowerIsEnabledAndMoveAbsoluteStartedIfNegativeLimitHitThenMoveAbsoluteAbortedStatus_Test5
VAR_INST
    fbTestTimer : TON := (PT := T#3S, IN := TRUE);
    nTestStateStep : INT;
    // Subject under tests
    fbMoveAbsolute : FB_MoveAbsoluteNC(AxisRef := fbAxisRef[5]);
    // simulate limit hit event
    fbPower :  FB_PowerNC(AxisRef := fbAxisRef[5]);
    fbLimtHitTimer : TON := (PT := T#1S, IN := FALSE);
    fExpectedPosition: LREAL := 50.0;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// must be called cycliclly
// one issue , directional enables mmust be overridden during homing.
fbPower.Power(	Enable := TRUE,
                  Enable_Positive := fbLimSwStatus[5].LimForward,
                   Enable_Negative := fbLimSwStatus[5].LimBackward,
                Override := 100
              );

CASE nTestStateStep OF
    0 :
        IF fbPower.PowerIsEnabled THEN
            nTestStateStep := nTestStateStep + 1;
        END_IF

    1 :
        fbMoveAbsolute.MoveAbsolute(	Position := -150.0,
                                          Velocity := 100,
                                          Acceleration := 200,
                                          Deceleration := 200
                                    );
        fbLimtHitTimer.IN := TRUE;
        nTestStateStep := nTestStateStep + 1;
    2 :
        IF fbLimtHitTimer.Q THEN
            fbLimSwStatus[5].LimBackward := FALSE;
            nTestStateStep := nTestStateStep + 1;
        END_IF
    3 :
        IF fbMoveAbsolute.Aborted THEN
            nTestStateStep := nTestStateStep + 1;
        END_IF
    4:;

END_CASE
//
fbLimtHitTimer();
fbTestTimer();
fbAxisRef[5].ReadStatus();
fbMoveAbsolute();

IF nTestStateStep = 4 THEN
    AssertTrue(Condition :=  fbAxisRef[5].Status.HasBeenStopped, Message := 'Expected HasBeenStopped');
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStateStep))
    );

    TEST_FINISHED();
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenThatDirectionalPositivePowerIsEnabledAndMoveAbsoluteStartedIfPositiveLimitHitThenMoveAbsoluteAbortedStatus_Test4" Id="{903b34b2-f5e3-4716-a670-9db554d02b7b}">
      <Declaration><![CDATA[METHOD PRIVATE GivenThatDirectionalPositivePowerIsEnabledAndMoveAbsoluteStartedIfPositiveLimitHitThenMoveAbsoluteAbortedStatus_Test4
VAR_INST
    fbTestTimer : TON := (PT := T#3S, IN := TRUE);
    nTestStateStep : INT;
    // Subject under tests
    fbMoveAbsolute : FB_MoveAbsoluteNC(AxisRef := fbAxisRef[4]);
    // simulate limit hit event
    fbPower :  FB_PowerNC(AxisRef := fbAxisRef[4]);
    fbLimtHitTimer : TON := (PT := T#1S, IN := FALSE);
    fExpectedPosition: LREAL := 50.0;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

// must be called cycliclly
// one issue , directional enables mmust be overridden during homing.
fbPower.Power(	Enable := TRUE,
                  Enable_Positive := fbLimSwStatus[4].LimForward,
                   Enable_Negative := fbLimSwStatus[4].LimBackward,
                Override := 100
              );

CASE nTestStateStep OF
    0 :
        IF fbPower.PowerIsEnabled THEN
            nTestStateStep := nTestStateStep + 1;
        END_IF

    1 :
        fbMoveAbsolute.MoveAbsolute(	Position := 150,
                                          Velocity := 100,
                                          Acceleration := 200,
                                          Deceleration := 200
                                    );
        fbLimtHitTimer.IN := TRUE;
        nTestStateStep := nTestStateStep + 1;
    2 :
        IF fbLimtHitTimer.Q THEN
            fbLimSwStatus[4].LimForward := FALSE;
            nTestStateStep := nTestStateStep + 1;
        END_IF
    3 :
        IF fbMoveAbsolute.Aborted THEN
            nTestStateStep := nTestStateStep + 1;
        END_IF
    4:;

END_CASE
//
fbLimtHitTimer();
fbTestTimer();
fbAxisRef[4].ReadStatus();
fbMoveAbsolute();

IF nTestStateStep = 4 THEN
    AssertTrue(Condition :=  fbAxisRef[4].Status.HasBeenStopped, Message := 'Expected HasBeenStopped');
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStateStep))
    );

    TEST_FINISHED();
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenThatPowerIsEnabledAndMoveAbsoluteStartedAndCompletedThenMoveAbsoluteRetainsDoneStatus_Test1" Id="{d6224050-ec2d-4785-a811-d10c9555be8b}">
      <Declaration><![CDATA[METHOD PRIVATE GivenThatPowerIsEnabledAndMoveAbsoluteStartedAndCompletedThenMoveAbsoluteRetainsDoneStatus_Test1
VAR_INST
    fbTestTimer : TON := (PT := T#3S, IN := TRUE);
    nTestStateStep : INT;
    fbMoveAbsolute : FB_MoveAbsoluteNC(AxisRef := fbAxisRef[1]);
    fbPower :   FB_PowerNC(AxisRef := fbAxisRef[1]);
    fExpectedPosition: LREAL := 50.0;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

fbPower.Power(	Enable := TRUE,
                  Enable_Positive := fbLimSwStatus[1].LimForward,
                   Enable_Negative := fbLimSwStatus[1].LimBackward,
                Override := 100
              );

CASE nTestStateStep OF
    0 :
        IF fbPower.PowerIsEnabled THEN
            nTestStateStep := nTestStateStep + 1;
        END_IF

    1 :
        fbMoveAbsolute.MoveAbsolute(Position := 50,
                                      Velocity := 500,
                                      Acceleration := 1000,
                                      Deceleration := 1000);
        nTestStateStep := nTestStateStep + 1;

    2 :
        IF fbMoveAbsolute.Done THEN
            nTestStateStep := nTestStateStep + 1;
        END_IF
END_CASE

fbTestTimer();
fbAxisRef[1].ReadStatus();
fbMoveAbsolute();

IF nTestStateStep = 3 THEN
    AssertEquals_LREAL ( Delta:=0.001, Expected:=fExpectedPosition, Actual:=fbAxisRef[1].NcToPlc.ActPos, Message:='Position is not the expected #1');
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStateStep))
    );

    TEST_FINISHED();
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenThatPowerIsEnabledAndMoveAbsoluteStartedFollowByAHaltSignalThenMoveIsAbortedAndHaltDoneIsRetained_Test2" Id="{b69b45e8-b2d6-406e-88d9-5d68b04e79a5}">
      <Declaration><![CDATA[METHOD PRIVATE GivenThatPowerIsEnabledAndMoveAbsoluteStartedFollowByAHaltSignalThenMoveIsAbortedAndHaltDoneIsRetained_Test2
VAR_INST

    fbTestTimer : TON := (PT := T#3S, IN := TRUE);
    fbInMotionTimer : TON := (PT := T#1S, IN := FALSE);
    nTestStateStep : INT;
    fbPower :   FB_PowerNC(AxisRef := fbAxisRef[2]);
    // Subjects under test
    fbMoveAbsolute : FB_MoveAbsoluteNC(AxisRef := fbAxisRef[2]);
    fbHalt : FB_HaltNC(AxisRef := fbAxisRef[2]);

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());


fbPower.Power(	Enable := TRUE,
                  Enable_Positive := fbLimSwStatus[2].LimForward,
                   Enable_Negative := fbLimSwStatus[2].LimBackward,
                Override := 100
              );

CASE nTestStateStep OF
    0 :

        IF fbPower.PowerIsEnabled THEN
            nTestStateStep := nTestStateStep + 1;
        END_IF
    1 :
        fbMoveAbsolute.MoveAbsolute(Position := 100,
                                      Velocity := 100,
                                      Acceleration :=50,
                                      Deceleration := 50);
        nTestStateStep := nTestStateStep + 1;
    2 :
        IF fbMoveAbsolute.Busy THEN
            fbInMotionTimer.IN := TRUE;
            nTestStateStep := nTestStateStep + 1;
        END_IF

    3 :
         IF fbInMotionTimer.Q THEN
            fbHalt.Halt(    Deceleration:=100, Jerk:=0 );
            fbInMotionTimer.IN := FALSE;
            nTestStateStep := nTestStateStep + 1;
        END_IF
    4 :
        IF  fbHalt.Done THEN
            nTestStateStep := nTestStateStep + 1;
        END_IF
    5 : // Do nothing
END_CASE

fbTestTimer();
fbInMotionTimer();
fbAxisRef[2].ReadStatus();
fbMoveAbsolute();
fbHalt();

IF nTestStateStep = 5 THEN
    AssertTrue(Condition := fbMoveAbsolute.Aborted,
               Message := 'Expected CommandAborted');
    AssertTrue(Condition := fbHalt.Done,
                Message := 'Expected Done');
    AssertFalse(Condition := fbHalt.Busy,
                Message := 'Expected not busy');
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStateStep))
    );

    TEST_FINISHED();
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenThatPowerIsEnabledAndMoveAbsoluteStartedFollowByAResetSignalThenMoveIsAbortedAndResetDoneIsRetained_Test3" Id="{92ac79f2-3e81-4622-8597-aa483d9ef4da}">
      <Declaration><![CDATA[METHOD PRIVATE GivenThatPowerIsEnabledAndMoveAbsoluteStartedFollowByAResetSignalThenMoveIsAbortedAndResetDoneIsRetained_Test3
VAR_INST
    fbTestTimer : TON := (PT := T#3S, IN := TRUE);
    fbInMotionTimer : TON := (PT := T#1S, IN := FALSE);
    nTestStateStep : INT;
    fbPower :   FB_PowerNC(AxisRef := fbAxisRef[3]);
    // Subjects under test
    fbMoveAbsolute : FB_MoveAbsoluteNC(AxisRef := fbAxisRef[3]);
    fbReset : FB_ResetNC(AxisRef := fbAxisRef[3]);

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

fbPower.Power(	Enable := TRUE,
                  Enable_Positive := fbLimSwStatus[3].LimForward,
                   Enable_Negative := fbLimSwStatus[3].LimBackward,
                Override := 100
              );
CASE nTestStateStep OF
    0 :

        IF fbPower.PowerIsEnabled THEN
            nTestStateStep := nTestStateStep + 1;
        END_IF
    1 :
        fbMoveAbsolute.MoveAbsolute(Position := 100,
                                      Velocity := 100,
                                      Acceleration :=50,
                                      Deceleration := 50);
        nTestStateStep := nTestStateStep + 1;
    2 :
        IF fbMoveAbsolute.Busy THEN
            fbInMotionTimer.IN := TRUE;
            nTestStateStep := nTestStateStep + 1;
        END_IF

    3 :
         IF fbInMotionTimer.Q THEN
            fbReset.Reset();
            fbInMotionTimer.IN := FALSE;
            nTestStateStep := nTestStateStep + 1;
        END_IF
    4 :
        IF  fbReset.Done THEN
            nTestStateStep := nTestStateStep + 1;
        END_IF
    5 : // Do nothing
END_CASE

fbInMotionTimer();
fbAxisRef[3].ReadStatus();
fbMoveAbsolute();
fbReset();
fbTestTimer();

IF nTestStateStep = 5 THEN
    AssertTrue(Condition := fbMoveAbsolute.Aborted,
               Message := 'Expected CommandAborted');
    AssertTrue(Condition := fbReset.Done,
                Message := 'Expected Done');
    AssertFalse(Condition := fbReset.Busy,
                Message := 'Expected not busy');
    TEST_FINISHED();
ELSIF fbTestTimer.Q THEN
    AssertTrue(
        Condition := FALSE,
        Message := CONCAT('Timed out at step: ', TO_STRING(nTestStateStep))
    );

    TEST_FINISHED();
END_IF

]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>