<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_MotionInterlocksLimSw_Test" Id="{da3c97b2-4b6a-442f-b566-7fa9056337b4}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_MotionInterlocksLimSw_Test EXTENDS FB_TestSuite
VAR
    fbLimSwStatus: ARRAY [1..6] OF FB_LimSwStatus_testDouble;
    fbMotionInterlocksCommon:  ARRAY [1..6] OF  FB_MotionInterlocksCommon_TestDouble;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[GivenPositiveLimHitEventIfGlobalResetOrNewMoveReqClearLocalFlags_Test1();
GivenLimSwStatusEventIfStandStillUpdateBackwardAndFowardEnable_Test2();
GivenCommonInterlockErrorsThenSetLocalErrors_Test3();
GivenLimForwardAndBackwardActiveAxisMovingInNegativeDirectionIfPosiveLimishitThenNoLimHitEvent_Test4();
GivenLimForwardAndBackwardActiveAxisMovingInPosiveDirectionIfPosiveLimishitThenLimHitEventOccured_test5();
GivenLimSwStatusActiveAndAxisHomingInPosOrNegDirectionThenNoLimHitEvent_Test6();




]]></ST>
    </Implementation>
    <Method Name="GivenCommonInterlockErrorsThenSetLocalErrors_Test3" Id="{94ef42a6-f7bb-4549-ab69-eec32e85b91b}">
      <Declaration><![CDATA[METHOD GivenCommonInterlockErrorsThenSetLocalErrors_Test3
VAR_INST
    nExpectedErrorId: UDINT := 1;
    nActErrorId: UDINT;
    sExpectedMessage: STRING := 'User enable interlock triggered!';
    sActMessage: STRING;
    // subject under test
    fbMotionInterlocksLimSw : FB_MotionInterlocksLimSw(iMotionInterlocksCommon:=fbMotionInterlocksCommon[3], iLimSwStatus:=fbLimSwStatus[3]);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());
// Test UserEnable interlock trigger
fbMotionInterlocksCommon[3].Error := TRUE;
fbMotionInterlocksCommon[3].ErrorID:=1;
fbMotionInterlocksCommon[3].Message:=sExpectedMessage;
fbMotionInterlocksCommon[3]();
fbMotionInterlocksLimSw();

AssertTrue(Condition := fbMotionInterlocksLimSw.Error,
           Message := 'Common interlock event must set this error #1');

nActErrorId := fbMotionInterlocksLimSw.ErrorID;
AssertEquals ( Expected:=nExpectedErrorId, Actual:=nActErrorId ,
            Message:='Common interlock event must set this errorId #2');

sActMessage := fbMotionInterlocksLimSw.Message;
AssertEquals ( Expected:=sExpectedMessage, Actual:=sActMessage,
            Message:='Common interlock event must set this error msg #3');

fbMotionInterlocksCommon[3].ResetErrors();
fbMotionInterlocksCommon[3]();
fbMotionInterlocksLimSw();

TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenLimForwardAndBackwardActiveAxisMovingInNegativeDirectionIfPosiveLimishitThenNoLimHitEvent_Test4" Id="{ed589f98-23fe-4027-ac60-fcf98aa8e006}">
      <Declaration><![CDATA[METHOD GivenLimForwardAndBackwardActiveAxisMovingInNegativeDirectionIfPosiveLimishitThenNoLimHitEvent_Test4
VAR_INST
    tonLimSwStatusEvent : TON := (IN:=TRUE, PT:=T#0S);
    fbMotionInterlocksLimSw : FB_MotionInterlocksLimSw(iMotionInterlocksCommon:=fbMotionInterlocksCommon[4], iLimSwStatus:=fbLimSwStatus[4]);
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());
tonLimSwStatusEvent();
fbLimSwStatus[4].LimForward := TRUE;
fbLimSwStatus[4].LimBackward := TRUE;
fbLimSwStatus[4]();
fbMotionInterlocksLimSw.AxisStatus(HomeBusy:=FALSE, PositiveDirection:=FALSE, NegativeDirection:=TRUE);
fbMotionInterlocksLimSw();


IF tonLimSwStatusEvent.Q THEN
    fbLimSwStatus[4].LimForward := FALSE;
    fbLimSwStatus[4]();
    tonLimSwStatusEvent.IN:=FALSE;
END_IF

fbMotionInterlocksLimSw();

AssertFalse(Condition := fbMotionInterlocksLimSw.Warning,
           Message := 'No Warning event expected #1');
AssertFalse(Condition := fbMotionInterlocksLimSw.LimHit,
           Message := 'No Lim Hit event expected #2');
TEST_FINISHED();


]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenLimForwardAndBackwardActiveAxisMovingInPosiveDirectionIfPosiveLimishitThenLimHitEventOccured_Test5" Id="{cde5b974-2818-4742-bb16-32a8067eb591}">
      <Declaration><![CDATA[METHOD GivenLimForwardAndBackwardActiveAxisMovingInPosiveDirectionIfPosiveLimishitThenLimHitEventOccured_Test5
VAR_INST
    tonLimSwStatusEvent : TON := (IN:=TRUE, PT:=T#0S);
    fbMotionInterlocksLimSw : FB_MotionInterlocksLimSw(iMotionInterlocksCommon:=fbMotionInterlocksCommon[5], iLimSwStatus:=fbLimSwStatus[5]);
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());
tonLimSwStatusEvent();
fbLimSwStatus[5].LimForward := TRUE;
fbLimSwStatus[5].LimBackward := TRUE;
fbMotionInterlocksLimSw.AxisStatus(HomeBusy:=FALSE, PositiveDirection:=TRUE, NegativeDirection:=FALSE);
fbLimSwStatus[5]();
fbMotionInterlocksLimSw();

IF tonLimSwStatusEvent.Q THEN
    fbLimSwStatus[5].LimForward := FALSE;
    tonLimSwStatusEvent.IN := FALSE;
END_IF

fbLimSwStatus[5]();
fbMotionInterlocksLimSw();

AssertTrue(Condition := fbMotionInterlocksLimSw.Warning,
                   Message := 'Expecting a Warning event after positive lim hit #1');
AssertTrue(Condition := fbMotionInterlocksLimSw.LimHit,
                   Message := 'Expecting a Limit hit event after positive lim hit #2');
TEST_FINISHED();

]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenLimSwStatusActiveAndAxisHomingInPosOrNegDirectionThenNoLimHitEvent_Test6" Id="{48a68bdb-791b-428f-85bd-1be319b9fa11}">
      <Declaration><![CDATA[METHOD GivenLimSwStatusActiveAndAxisHomingInPosOrNegDirectionThenNoLimHitEvent_Test6
VAR_INST
    fbMotionInterlocksLimSw : FB_MotionInterlocksLimSw(iMotionInterlocksCommon:=fbMotionInterlocksCommon[6], iLimSwStatus:=fbLimSwStatus[6]);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());

fbLimSwStatus[6].LimForward := TRUE;
fbLimSwStatus[6].LimBackward := TRUE;
fbMotionInterlocksLimSw.AxisStatus(HomeBusy:=TRUE, PositiveDirection:=TRUE, NegativeDirection:=FALSE);
fbLimSwStatus[6]();
fbMotionInterlocksLimSw();

AssertFalse(Condition := fbMotionInterlocksLimSw.Warning,
           Message := 'Warning event while homing unexpected #1');

AssertFalse(Condition := fbMotionInterlocksLimSw.LimHit,
           Message := 'Lim hit event while homing unexpected #2');

fbMotionInterlocksLimSw.AxisStatus(HomeBusy:=TRUE, PositiveDirection:=FALSE, NegativeDirection:=TRUE);
fbLimSwStatus[6]();
fbMotionInterlocksLimSw();

AssertFalse(Condition := fbMotionInterlocksLimSw.Warning,
           Message := 'Warning event while homing unexpected #3');

AssertFalse(Condition := fbMotionInterlocksLimSw.LimHit,
           Message := 'Lim hit event while homing unexpected #4');

TEST_FINISHED();

]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenLimSwStatusEventIfStandStillUpdateBackwardAndFowardEnable_Test2" Id="{cf0a87d6-b613-4bab-bdaf-73e10f361f1f}">
      <Declaration><![CDATA[METHOD GivenLimSwStatusEventIfStandStillUpdateBackwardAndFowardEnable_Test2
VAR_INST
    fbMotionInterlocksLimSw : FB_MotionInterlocksLimSw(iMotionInterlocksCommon:=fbMotionInterlocksCommon[2], iLimSwStatus:=fbLimSwStatus[2]);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());
// Test LimSwStatus Events and update backward and forward Enable
fbLimSwStatus[2].LimForward := TRUE;
fbLimSwStatus[2].LimBackward := TRUE;
fbMotionInterlocksLimSw.AxisStatus(HomeBusy:=FALSE, PositiveDirection:=FALSE, NegativeDirection:=FALSE);
fbLimSwStatus[2]();
fbMotionInterlocksLimSw();

AssertTrue(Condition := fbMotionInterlocksLimSw.MoveBackwardEnabled,
           Message := 'MoveBackwardEnabled must be set #1');

AssertTrue(Condition := fbMotionInterlocksLimSw.MoveForwardEnabled,
           Message := 'MoveForwardwardEnabled must be set #2');

fbLimSwStatus[2].LimForward := FALSE;
fbLimSwStatus[2].LimBackward := FALSE;
fbMotionInterlocksLimSw.AxisStatus(HomeBusy:=FALSE, PositiveDirection:=FALSE, NegativeDirection:=FALSE);
fbLimSwStatus[2]();
fbMotionInterlocksLimSw();

AssertFalse(Condition := fbMotionInterlocksLimSw.MoveBackwardEnabled,
           Message := 'MoveBackwardEnabled must not be set #3');

AssertFalse(Condition := fbMotionInterlocksLimSw.MoveForwardEnabled,
           Message := 'MoveForwardwardEnabled must not be set #4');

TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
    <Method Name="GivenPositiveLimHitEventIfGlobalResetOrNewMoveReqClearLocalFlags_Test1" Id="{c69f1b81-3118-4011-9ebf-118fdb3c44fe}">
      <Declaration><![CDATA[METHOD GivenPositiveLimHitEventIfGlobalResetOrNewMoveReqClearLocalFlags_Test1
VAR_INST
    fbMotionInterlocksLimSw : FB_MotionInterlocksLimSw(iMotionInterlocksCommon:=fbMotionInterlocksCommon[1], iLimSwStatus:=fbLimSwStatus[1]);
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST(__POUNAME());
fbLimSwStatus[1].LimForward := TRUE;
fbLimSwStatus[1].LimBackward := TRUE;
fbMotionInterlocksLimSw.AxisStatus(HomeBusy:=FALSE, PositiveDirection:=TRUE, NegativeDirection:=FALSE);
fbLimSwStatus[1]();
fbMotionInterlocksLimSw();

// Create Forward limit hit event
fbLimSwStatus[1].LimForward := FALSE;
fbLimSwStatus[1]();
fbMotionInterlocksLimSw();

// Reset Flags
fbMotionInterlocksLimSw.Reset();
fbMotionInterlocksLimSw();

AssertFalse(Condition := fbMotionInterlocksLimSw.Warning,
               Message := 'Warning should be cleared #1');
AssertFalse(Condition := fbMotionInterlocksLimSw.LimHit,
               Message := 'Limit hit flag should be cleared #2');




//Rest axis
fbLimSwStatus[1].LimForward := TRUE;
fbLimSwStatus[1].LimBackward := TRUE;
fbLimSwStatus[1]();
fbMotionInterlocksLimSw.DriveCommands(Enable:=FALSE, NewMoveReq:=FALSE);
fbMotionInterlocksLimSw.AxisStatus(HomeBusy:=FALSE, PositiveDirection:=FALSE, NegativeDirection:=FALSE);
fbMotionInterlocksLimSw();

// Discrete motion in negative direction
fbMotionInterlocksLimSw.AxisStatus(HomeBusy:=FALSE, PositiveDirection:=FALSE, NegativeDirection:=TRUE);
fbMotionInterlocksLimSw();

// Create backward limit hit event
fbLimSwStatus[1].LimBackward := FALSE;
fbLimSwStatus[1]();
fbMotionInterlocksLimSw();

// clear Flags from global reset
fbMotionInterlocksLimSw.Reset();
fbMotionInterlocksLimSw();

AssertFalse(Condition := fbMotionInterlocksLimSw.Warning,
               Message := 'Warning should be cleared #3');
AssertFalse(Condition := fbMotionInterlocksLimSw.LimHit,
               Message := 'Limit hit flag should be cleared #4');



//Rest axis
fbLimSwStatus[1].LimForward := TRUE;
fbLimSwStatus[1].LimBackward := TRUE;
fbLimSwStatus[1]();
fbMotionInterlocksLimSw.DriveCommands(Enable:=FALSE, NewMoveReq:=FALSE);
fbMotionInterlocksLimSw.AxisStatus(HomeBusy:=FALSE, PositiveDirection:=FALSE, NegativeDirection:=FALSE);
fbMotionInterlocksLimSw();

// Discrete motion in positive direction
fbMotionInterlocksLimSw.AxisStatus(HomeBusy:=FALSE, PositiveDirection:=TRUE, NegativeDirection:=FALSE);
fbMotionInterlocksLimSw();

// Create forward limit hit event
fbLimSwStatus[1].LimForward := FALSE;
fbLimSwStatus[1]();
fbMotionInterlocksLimSw();

// clear Flags from global reset
fbMotionInterlocksLimSw.DriveCommands(Enable:=FALSE, NewMoveReq:=TRUE);
fbMotionInterlocksLimSw();

AssertFalse(Condition := fbMotionInterlocksLimSw.Warning,
               Message := 'Warning should be cleared #5');
AssertFalse(Condition := fbMotionInterlocksLimSw.LimHit,
               Message := 'Limit hit flag should be cleared #6');

TEST_FINISHED();
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>