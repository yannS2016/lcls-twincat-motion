<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_MotionDrive" Id="{60d91316-04e3-4af1-aaa1-6a890af932f7}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_MotionDrive IMPLEMENTS I_MotionDrive
VAR
    {attribute 'hide'}
    iMoveRequest : I_MoveRequest;
    {attribute 'hide'}
    iEpicsMotionParamsStatus : I_EpicsMotionParamsStatus;
    {attribute 'hide'}
    iMotionAxis: I_MotionAxis;
    iMotionAxisDS402: I_MotionAxisDS402;
    {attribute 'hide'}
    iBrake 				: I_Brake;
    {attribute 'hide'}
    iMotionInterlocks	: I_MotionInterlocks;
    {attribute 'hide'}
    iMotionLogger 		: I_MotionLogger;
    iMotionDriveStateMachine : I_MotionDriveStateMachine;
    {attribute 'hide'}
    sName : STRING;
    bError: BOOL;
    nErrorId: UDINT;
    sErrorMessage: T_MAXSTRING;
    {attribute 'hide'}
    rtReset: R_TRIG;
    {attribute 'hide'}
    rtStop: R_TRIG;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Restore axis parameters pass in a struct ref of parameters to restore
iMoveRequest.RestoreSettings(
    RestoreDone:=iMotionAxis.Status.bRestoreDone,
    SavedPosition:=iMotionAxis.Status.fSavedPosition
);

// catch high priority message
// an extended error message from FB_MotionLogger will display cyclic errors and warning
IF iMotionAxis.Status.bError THEN
    bError := iMotionAxis.Status.bError;
    nErrorId := iMotionAxis.Status.nErrorID;
    sErrorMessage:= iMotionAxis.Status.sMessage;
ELSIF iMotionInterlocks.Error THEN
    bError := iMotionInterlocks.Error;
    nErrorId := iMotionInterlocks.ErrorID;
    sErrorMessage:= iMotionInterlocks.Message;
// Warnings have lowest priority
ELSIF iMotionInterlocks.Warning THEN
    sErrorMessage:= iMotionInterlocks.Message;
END_IF

iMoveRequest.MoveRequestError(
    Error := bError,
    ErrorId :=nErrorId,
    ErrorMessage:=sErrorMessage
);
//
iMoveRequest.MoveRequest(
    EnableDone:=iMotionAxis.AxisEnabled(),
    MoveOk:=iMotionInterlocks.MoveOk
);
// Forward Move requests status to interlock blocks
iMotionInterlocks.DriveCommands(
    Enable:= iMoveRequest.Status.bEnable,
    NewMoveReq:=iMoveRequest.Status.bNewMoveReq
);
// Forward Power block enable flags
iMotionAxis.Power(
    Enable:=iMotionInterlocks.PowerEnabled,
    Enable_Positive:=iMoveRequest.Status.bExecHome OR iMotionInterlocks.MoveForwardEnabled,
    Enable_Negative:=iMoveRequest.Status.bExecHome OR iMotionInterlocks.MoveBackwardEnabled,
    Override	:= 100.0,
    BufferMode	:= MC_Aborting
);

// Halt the Move
rtStop(CLK:=iMoveRequest.HaltMoveRequest(Busy:=iMotionAxis.Status.bBusy));
IF rtStop.Q THEN
    iMotionAxis.Halt(Deceleration:=iMoveRequest.Status.fDeceleration);
END_IF
// Reset
rtReset(CLK:=iMoveRequest.Status.bReset);
IF rtReset.Q THEN
    bError := FALSE;
    nErrorId := 0;
    sErrorMessage:= '';
    iMoveRequest.Status.bReset := FALSE;
   // Forward general reset event
   iMotionAxis.Reset();
   iMotionInterlocks.Reset();
END_IF

iMotionInterlocks.AxisStatus(
    HomeBusy:=iMotionAxis.Status.bHomeBusy,
    PositiveDirection:=iMotionAxis.Status.bPositiveMotionIsEnabled,
    NegativeDirection:=iMotionAxis.Status.bNegativeMotionIsEnabled
);

// Drive state machine
iMotionDriveStateMachine.StateMachine(
    InterlockEvent:= iMotionInterlocks.InterlockEvent,
    Error	:=bError
);

// Forward axis state to brake FB
iBrake.AxisState := iMotionAxis.Status.eAxisState;

// Read Axis Parameter
iMotionAxis.ReadAxisParams(
    Enable:=TRUE,
    RefreshDelay:=T#1S
);

// Save and Restore
iMotionAxis.SaveAxisParams(Enable:=TRUE);

// update EPICS status
iEpicsMotionParamsStatus.MotionParamsAndStatus(
    PowerEnabled := iMotionInterlocks.PowerEnabled,
    PowerIsEnabled := iMotionAxis.Status.bPowerIsEnabled,
    Execute := iMoveRequest.Status.bExecute,
    LimHome := iMotionInterlocks.LimHome,
    MoveBackwardEnabled := iMotionInterlocks.MoveBackwardEnabled,
    MoveForwardEnabled := iMotionInterlocks.MoveForwardEnabled,
    MeasuredPositionDiff := iMotionAxis.Status.fMeasuredPositionDiff,
    MeasuredPosition := iMotionAxis.Status.fMeasuredPosition,
    MeasuredVelocity := iMotionAxis.Status.fMeasuredVelocity,
    PowerOverride := iMotionAxis.Status.fPowerOverride,
    Busy := iMotionAxis.Status.bBusy,
    HomeDone := iMotionAxis.Status.bHomeDone,
    MotionAxisId:=iMotionAxis.Status.nAxisId
);]]></ST>
    </Implementation>
    <Method Name="CallAfterInit" Id="{f39ddf47-4815-43e7-8049-e534fb9f6092}">
      <Declaration><![CDATA[METHOD PUBLIC CallAfterInit
VAR_INPUT
    iBrake : I_Brake;
    iMotionInterlocks : I_MotionInterlocks;
    iMotionLogger : I_MotionLogger;
    iMotionAxis: I_MotionAxis;
    iMoveRequest : I_MoveRequest;
    iEpicsMotionParamsStatus : I_EpicsMotionParamsStatus;
    iMotionDriveStateMachine : I_MotionDriveStateMachine;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.iMotionAxis := iMotionAxis;
THIS^.iMotionLogger:=iMotionLogger;
THIS^.iBrake:=iBrake;
THIS^.iMotionInterlocks:=iMotionInterlocks;
THIS^.iMoveRequest :=iMoveRequest;
THIS^.iEpicsMotionParamsStatus := iEpicsMotionParamsStatus;
THIS^.iMotionDriveStateMachine := iMotionDriveStateMachine;]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_Init" Id="{927f7c72-9006-42d1-8ac3-5d4ce66d6511}">
      <Declaration><![CDATA[//FB_Init is always available implicitly and it is used primarily for initialization.
//The return value is not evaluated. For a specific influence, you can also declare the
//methods explicitly and provide additional code there with the standard initialization
//code. You can evaluate the return value.
METHOD FB_Init: BOOL
VAR_INPUT
    bInitRetains: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInCopyCode: BOOL;  // TRUE: the instance will be copied to the copy code afterward (online change)
    iBrake : I_Brake;
    iMotionInterlocks : I_MotionInterlocks;
    iMotionLogger : I_MotionLogger;
    iMotionAxis: I_MotionAxis;
    iMoveRequest : I_MoveRequest;
    iEpicsMotionParamsStatus : I_EpicsMotionParamsStatus;
    iMotionDriveStateMachine : I_MotionDriveStateMachine;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.iMotionAxis := iMotionAxis;
THIS^.iMotionLogger:=iMotionLogger;
THIS^.iBrake:=iBrake;
THIS^.iMotionInterlocks:=iMotionInterlocks;
THIS^.iMoveRequest :=iMoveRequest;
THIS^.iEpicsMotionParamsStatus := iEpicsMotionParamsStatus;
THIS^.iMotionDriveStateMachine := iMotionDriveStateMachine;

]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>