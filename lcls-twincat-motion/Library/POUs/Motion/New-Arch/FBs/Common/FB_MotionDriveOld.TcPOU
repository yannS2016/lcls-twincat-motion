<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_MotionDriveOld" Id="{4b865f82-fa35-4064-9c9b-a4b6d3446d31}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_MotionDriveOld IMPLEMENTS I_MotionDrive
VAR
   // EPICS Interface
    {attribute 'no_copy'}
    stMotionEpicsItf : REFERENCE TO ST_MotionEpicsInterface;
    {attribute 'hide'}
    iMoveRequest : I_MoveRequest;
    {attribute 'hide'}
    iEpicsMotionParamsStatus : I_EpicsMotionParamsStatus;
    {attribute 'hide'}
    iMotionAxis: I_MotionAxis;
    iMotionAxisDS402: I_MotionAxisDS402;
    {attribute 'hide'}
    iBrake 				: I_Brake;
    {attribute 'hide'}
    iMotionInterlocks	: I_MotionInterlocks;
    {attribute 'hide'}
    iMotionLogger 		: I_MotionLogger;
    iStateMachine : I_MotionDriveStateMachine;

    sName : STRING;
    {attribute 'hide'}
    eMoveState	: E_MoveState;
    rtTarget			: R_TRIG;
    rtResetDone : R_TRIG;
    {attribute 'hide'}
    rtHomed				: R_TRIG;
    {attribute 'hide'}
    rtValidExec 	: R_TRIG;
    {attribute 'hide'}
    rtReset 			: R_TRIG;
    {attribute 'hide'}
    ftStopExec 			: F_TRIG;
    {attribute 'hide'}
    ftError 			: F_TRIG;
    {attribute 'hide'}
    bInitStart : BOOL;
    {attribute 'hide'}
    {attribute 'hide'}
    bPrepareDisable : BOOL;
    {attribute 'hide'}
    rtStopExec : R_TRIG;
    {attribute 'hide'}
    rtInterlockEvent : R_TRIG;
    rtHaltEvent : R_TRIG;
    {attribute 'hide'}
    bCmdExecute : BOOL;
    {attribute 'hide'}
    bHaltAbort : BOOL;
    {attribute 'hide'}
    ftHaltAbort : F_TRIG;
    {attribute 'hide'}
    rtRestoreDone : R_TRIG;
    {attribute 'hide'}
    bStop : BOOL;
    // move state machine to error state in case a move command gets stuck after
    // the corresponding start signal was forwarded. the start signal should yeild a busy true response.
    // the move processing block may get stuck and return no errors. this is a contingency to make sure that reset would reinit all state machines.
    tonSyncTimer : TON;
    bLocalError : BOOL;
    bLocalMessage : T_MAXSTRING;
    Execute: INT;
    rtTargetReached: R_TRIG;
    bError: BOOL;
    nErrorId: UDINT;
    sErrorMessage: T_MAXSTRING;
    tonMotionWatchDog: TON;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// IF NOT __ISVALIDREF( stMotionEpicsItf ) THEN
//    RETURN;
// END_IF
//
// // Restore axis parameters
// RestoreSettings();
//
// // catch high priority message
// // an extended error message from FB_MotionLogger will display cyclic errors and warning
// IF iMotionAxisNC.Status.bError THEN
// 	iMoveRequest.MotionStatus( bError := iMotionAxisNC.Status.bError,
// 								nErrorId := iMotionAxisNC.Status.nErrorID,
// 								sErrorMessage:= iMotionAxisNC.Status.sMessage
// 							);
// ELSIF iMotionInterlocks.Error THEN
// 	iMoveRequest.MotionStatus( bError := iMotionInterlocks.Error,
// 								nErrorId := iMotionInterlocks.ErrorID,
// 								sErrorMessage:= iMotionInterlocks.Message
// 							);
// // Warnings have lowest priority
// ELSIF iMotionInterlocks.Warning THEN
// 	iMoveRequest.MotionStatus( bError := FALSE,
// 								nErrorId := 0,
// 								sErrorMessage:= iMotionInterlocks.Message
// 							);
// END_IF
//
// //
// rtReset(CLK:=iMoveRequest.Status.bReset);
// rtResetDone(CLK:=iMotionAxisNC.Status.bResetDone);
//
// IF rtReset.Q THEN
//    // Forward general reset event
//    iMotionAxisNC.Reset();
//  ELSIF rtResetDone.Q THEN
// 	// Reset EPICS ENbale, disbale drive power.
// 	iMoveRequest.ClearEnable();
// END_IF
//
// //
// iMotionInterlocks.AxisStatus(
//       	HomeBusy:=iMotionAxisNC.Status.bHomeBusy,
//       	PositiveDirection:=iMotionAxisNC.Status.bPositiveMotionIsEnabled,
//        	NegativeDirection:=iMotionAxisNC.Status.bNegativeMotionIsEnabled
// );
// //
// iMoveRequest.MotionRequest(
// 	EnableDone:=iMotionAxisNC.AxisEnabled(),
// 	MoveOk:=iMotionInterlocks.MoveOk
// );
// // Forward drive commands to interlock blocks
// iMotionInterlocks.DriveCommands(
// 	Enable:= iMoveRequest.Status.bEnable,
// 	NewMoveReq:=iMoveRequest.Status.bNewMoveReq,
// 	Reset:=iMotionAxisNC.Status.bResetDone
// );
// // Forward Power block enable flags
// iMotionAxisNC.Power(
// 	Enable:=iMotionInterlocks.PowerEnabled,
// 	Enable_Positive:=iMotionInterlocks.MoveForwardEnabled,
// 	Enable_Negative:=iMotionInterlocks.MoveBackwardEnabled,
//     Override	:= 100.0,
//     BufferMode	:= MC_Aborting
// );
//
// ftStopExec(CLK:=stMotionEpicsItf.bExecute);
// // Halt is always a user stop but not an interlock event or a reset.
// bStop := ftStopExec.Q AND ((iMotionAxisNC.Status.bHomeBusy AND (iMoveRequest.Status.nCommand=10))
//                             OR(iMotionAxisNC.Status.bMoveAbsoluteBusy AND (iMoveRequest.Status.nCommand=3)));
//
// IF bStop THEN
// 	iMotionAxisNC.Halt(Deceleration:=stMotionEpicsItf.fDeceleration);
// 	bStop := FALSE;
// END_IF
//
// // Interlocks event i.e limit hit
// rtInterlockEvent(CLK:=iMotionInterlocks.InterlockEvent);
//
// // Drive state machine
// StateMachine();
//
// // Forward axis state to brake FB
// iBrake.AxisState := iMotionAxisNC.Status.eAxisState;
// // Read Axis Parameter
// iMotionAxisNC.ReadAxisParams(Enable:=TRUE, RefreshDelay:=T#1S);
//
// // Save and Restore
// iMotionAxisNC.SaveAxisParams(Enable:=TRUE);
//
// // update EPICS status
// iEpicsMotionParamsStatus.MotionParamsAndStatus(
// 						   PowerEnabled := iMotionInterlocks.PowerEnabled,
//                            PowerIsEnabled := iMotionAxisNC.Status.bPowerIsEnabled,
//                            Execute := iMoveRequest.Status.bExecute,
//                            LimHome := iMotionInterlocks.LimHome,
//                            MoveBackwardEnabled := iMotionInterlocks.MoveBackwardEnabled,
//                            MoveForwardEnabled := iMotionInterlocks.MoveForwardEnabled,
//                            MeasuredPositionDiff := iMotionAxisNC.Status.fMeasuredPositionDiff,
//                            MeasuredPosition := iMotionAxisNC.Status.fMeasuredPosition,
//                            MeasuredVelocity := iMotionAxisNC.Status.fMeasuredVelocity,
//                            PowerOverride := iMotionAxisNC.Status.fPowerOverride,
//                            Busy := iMotionAxisNC.Status.bBusy,
//                            HomeDone := iMotionAxisNC.Status.bHomeDone
//                   	);]]></ST>
    </Implementation>
    <Method Name="CallAfterInit" Id="{1eee5cf7-4b58-48fd-9c01-2f2808938328}">
      <Declaration><![CDATA[METHOD PUBLIC CallAfterInit
VAR_INPUT
    stMotionEpicsItf : REFERENCE TO ST_MotionEpicsInterface;
    iBrake : I_Brake;
    iMotionInterlocks : I_MotionInterlocks;
    iMotionLogger : I_MotionLogger;
    iMotionAxis: I_MotionAxis;
    iMoveRequest : I_MoveRequest;
    iEpicsMotionParamsStatus : I_EpicsMotionParamsStatus;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.stMotionEpicsItf REF=stMotionEpicsItf;
THIS^.iMotionAxis := iMotionAxis;
THIS^.iMotionLogger:=iMotionLogger;
THIS^.iBrake:=iBrake;
THIS^.iMotionInterlocks:=iMotionInterlocks;
THIS^.iMoveRequest :=iMoveRequest;
THIS^.iEpicsMotionParamsStatus := iEpicsMotionParamsStatus;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ClearVars" Id="{18d74b86-8d35-4b13-b887-415778f88e4d}">
      <Declaration><![CDATA[{warning 'Add method implementation '}
METHOD ClearVars
VAR_INPUT
    Done	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Property Name="EnableMode" Id="{20762de8-43ac-4d1e-a04f-0c481b171f5e}">
      <Declaration><![CDATA[PROPERTY EnableMode : ENUM_StageEnableMode
]]></Declaration>
      <Get Name="Get" Id="{654c96b6-3c94-4487-ae36-c97a070b352a}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[//EnableMode := eEnableMode;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{73b9a43c-5448-4293-996d-c8762ee1a34b}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[//eEnableMode := EnableMode;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="FB_Init" Id="{330c3067-b6c9-4e87-b2e5-5d0911673dcb}">
      <Declaration><![CDATA[//FB_Init is always available implicitly and it is used primarily for initialization.
//The return value is not evaluated. For a specific influence, you can also declare the
//methods explicitly and provide additional code there with the standard initialization
//code. You can evaluate the return value.
METHOD FB_Init: BOOL
VAR_INPUT
    bInitRetains: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInCopyCode: BOOL;  // TRUE: the instance will be copied to the copy code afterward (online change)
    stMotionEpicsItf : REFERENCE TO ST_MotionEpicsInterface;
    iBrake : I_Brake;
    iMotionInterlocks : I_MotionInterlocks;
    iMotionLogger : I_MotionLogger;
    iMotionAxis: I_MotionAxis;
    iMoveRequest : I_MoveRequest;
    iEpicsMotionParamsStatus : I_EpicsMotionParamsStatus;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.stMotionEpicsItf REF=stMotionEpicsItf;
THIS^.iMotionAxis := iMotionAxis;
THIS^.iMotionLogger:=iMotionLogger;
THIS^.iBrake:=iBrake;
THIS^.iMotionInterlocks:=iMotionInterlocks;
THIS^.iMoveRequest :=iMoveRequest;
THIS^.iEpicsMotionParamsStatus := iEpicsMotionParamsStatus;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Instances" Id="{6f7b1161-78f2-4b75-8324-b0f9973b4731}">
      <Declaration><![CDATA[{attribute 'call_after_init'}
METHOD Instances
VAR_INPUT
END_VAR

VAR

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// bMotionAxisNC  := __QUERYINTERFACE(iMotionAxisCommon, iMotionAxisNC) AND NOT __QUERYINTERFACE(iMotionAxisCommon,iMotionAxisCommonDS402);
// bMotionAxisNCDS402  := __QUERYINTERFACE(iMotionAxisCommon,iMotionAxisNCDS402) AND __QUERYINTERFACE(iMotionAxisCommon,iMotionAxisCommonDS402);
// bMotionAxisDS402  := __QUERYINTERFACE(iMotionAxisCommon, iMotionAxisDS402);
// bMotionInterlocks  := __QUERYINTERFACE(iMotionInterlocks,iMotionInterlocks) AND NOT __QUERYINTERFACE(iMotionInterlocks,iLimSw);
// bMotionInterlocksLimSw  := __QUERYINTERFACE(iMotionInterlocks,iMotionInterlocks) AND __QUERYINTERFACE(iMotionInterlocks,iLimSw);;]]></ST>
      </Implementation>
    </Method>
    <Property Name="Name" Id="{62c5f23d-d42a-455b-92ab-ed8f6b8d6274}">
      <Declaration><![CDATA[PROPERTY Name : STRING
]]></Declaration>
      <Get Name="Get" Id="{fde8dffa-0ced-4432-b994-1289d591d6ea}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Name := sName;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{e7f17751-ab89-4fb0-9119-52f775b7c252}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[sName := Name;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="PostHandling" Id="{645b1b32-b92f-4bec-825c-5a4360f45e41}">
      <Declaration><![CDATA[METHOD PostHandling
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="PreHandling" Id="{c17f1f1e-a4e0-44cd-a17f-b2c2e6b2489d}">
      <Declaration><![CDATA[METHOD PreHandling
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="RestoreSettings" Id="{4ece1bf1-f78b-4d94-ae7d-921b080c1af5}">
      <Declaration><![CDATA[METHOD RestoreSettings
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{6eb28a75-293c-4105-9f1f-a8ac0a60154b}">
      <Declaration><![CDATA[METHOD StateMachine
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// // prevent this state machine from hanging on user defined
// // configs
// IF tonMotionWatchDog.Q THEN
// 	bError := TRUE;
// 	nErrorId := 1;
// 	sErrorMessage:= 'Motion axis response timeout' ;
// 	eMoveState := E_MoveState.ERROR;
// END_IF
//
// rtTargetReached(CLK:=iMotionAxis.Status.bMoveAbsoluteDone);
// rtHomed(CLK:= iMotionAxis.Status.bHomeDone);
// ftError(CLK:=bError);
//
// // Drive state Machine here
// CASE eMoveState OF
//    E_MoveState.IDLING:
//         // Delay the disable until axis reach standstill
//         // and this state machine is idling
//         IF bError THEN
//                eMoveState := E_MoveState.ERROR;
//         ELSIF iMoveRequest.Status.bPrepareDisable AND iMotionAxis.Status.bStandStill THEN
// 			iMoveRequest.MoveRequestCompleted();
//         ELSIF iMoveRequest.Status.bExecMove OR iMoveRequest.Status.bExecHome THEN
// 			// When we start, set the busy/done appropriately
// 			iMoveRequest.InitMove();
// 			// Act as watch dog to set the drive in error state if axis side hangs.
// 			tonMotionWatchDog.IN:=TRUE;
//             eMoveState := E_MoveState.INIT;
//         END_IF
//
//    E_MoveState.INIT:
//
// 		CASE iMoveRequest.Status.nCommand OF
// 			E_EpicsMotorCmd.MOVE_ABSOLUTE:
// 				// Activate backlash compensation
// 				iMotionAxisNC.BacklashCompensation(
// 					bEnable:=TRUE,
// 					RampVelocity:=stMotionEpicsItf.fVelocity/10.0
// 				);
// 				IF __QUERYINTERFACE(iMotionAxis, iMotionAxisNC) THEN
// 					iMotionAxis.MoveAbsolute( Position:=stMotionEpicsItf.fPosition,
// 										  Velocity := stMotionEpicsItf.fVelocity,
// 										  Acceleration := stMotionEpicsItf.fAcceleration,
// 										  Deceleration := stMotionEpicsItf.fDeceleration
// 										);
// 					eMoveState := E_MoveState.STARTED;
// 				ELSIF __QUERYINTERFACE(iMotionAxis, iMotionAxisPiezo)
// 					// prepare piezo axis for motion
// 					IF iMotionAxisPiezo.ModeConfigDone(Mode:=E_EpicsMotorCmd.MOVE_ABSOLUTE) THEN
// 						iMotionAxis.MoveAbsolute( Position:=stMotionEpicsItf.fPosition,
// 										  Velocity := stMotionEpicsItf.fVelocity,
// 										  Acceleration := stMotionEpicsItf.fAcceleration,
// 										  Deceleration := stMotionEpicsItf.fDeceleration
// 						);
// 					eMoveState := E_MoveState.STARTED;
// 					END_IF
// 				END_IF
//
// 			E_EpicsMotorCmd.HOME:
// 				iMotionAxisNC.BacklashCompensation(
// 					bEnable:=FALSE,
// 					RampVelocity:=0.0
// 				);
// 				// Deactivate backlash compensation
// 				IF __QUERYINTERFACE(iMotionAxis, iMotionAxisNC) THEN
// 					iMotionAxis.home();
// 					eMoveState := E_MoveState.STARTED;
// 				ELSIF __QUERYINTERFACE(iMotionAxis, iMotionAxisPiezo)
// 					IF iMotionAxisPiezo.ModeConfigDone(Mode:=E_EpicsMotorCmd.HOME) THEN
// 						iMotionAxis.home();
// 						eMoveState := E_MoveState.STARTED;
// 					END_IF
//
// 				END_IF
// 		END_CASE
// 	E_MoveState.STARTED:
// 		IF bError THEN
// 			eMoveState := E_MoveState.ERROR;
// 		// when we get this signal, all motion prerequisite are met and axis is in motion.
// 		ELSIF iMotionAxis.Status.bBusy THEN
// 			tonMotionWatchDog.IN := FALSE;
// 			eMoveState := E_MoveState.IN_PROGRESS;
// 		END_IF
//
//    E_MoveState.IN_PROGRESS :
//
// 		IF bError THEN
//            eMoveState := E_MoveState.ERROR;
// 		// Move interupted: halt or Reset in motion will
// 		// Move Aborted: hitting a directional limit switch wil set Aborted flag.
// 		ELSIF iMotionAxis.Status.bAborted  THEN
//            eMoveState := E_MoveState.INTERRUPTED;
//
// 		ELSIF  rtTargetReached.Q OR rtHomed.Q  THEN
//            eMoveState := E_MoveState.REACHED;
// 		END_IF
//
//    E_MoveState.INTERRUPTED:
// 		// Interlock event aka limit hit ?
// 		IF iMotionInterlocks.InterlockEvent THEN
// 		   iMoveRequest.ResetMotionRequest(Done:=TRUE);
// 		   eMoveState := E_MoveState.IDLING;
// 		// Wait here for halt/reset done or clearing limit state to be restored
// 		ELSIF iMotionAxis.Status.bAbortDone THEN
//            iMoveRequest.ResetMotionRequest(Done:=TRUE);
//            eMoveState := E_MoveState.IDLING;
//        END_IF
//
//    E_MoveState.REACHED:
//        iMoveRequest.ResetMotionRequest(Done:=TRUE);
//        eMoveState := E_MoveState.IDLING;
//
//    E_MoveState.ERROR:
// 	   iMoveRequest.MoveRequestError(
// 				Error := bError,
// 				ErrorId :=nErrorId,
// 				ErrorMessage:=sErrorMessage
// 		);
//        IF ftError.Q THEN
//            eMoveState := E_MoveState.IDLING;
//        END_IF
// END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateParamAndStatus" Id="{60a510b0-54d4-47cb-b034-6bd58f65d909}">
      <Declaration><![CDATA[METHOD UpdateParamAndStatus]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>