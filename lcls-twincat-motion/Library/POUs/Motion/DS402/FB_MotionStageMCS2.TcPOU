<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_MotionStageMCS2" Id="{8a1beccb-8ae6-4cef-98b6-1d3261aefb9e}" SpecialFunc="None">
    <Declaration><![CDATA[(*
    MCS2 Motion Stage
    Controls a stage in CSP (NC), STEP_MODE, and Homing via DS402 interface.
    - Uses overridden Position Holding timer.
    - power enable mode must be 'DURING_MOTION' for closed-loop (CSP) control.
    - Set bServo PV to true for closed-loop, clear for open-loop (step mode).
*)

{attribute 'call_after_init'}
FUNCTION_BLOCK FB_MotionStageMCS2 IMPLEMENTS I_DS402GenericDrive

VAR
    // Reference to motion stage structure
    {attribute 'no_copy'}
    stMotionStage            : REFERENCE TO ST_MotionStage;

    // Hardware I/O
    stDS402Drive             : ST_DS402Drive;

    // ====== MC function blocks (hidden) ======
    {attribute 'hide'}
    eModule                  : E_Module;
    {attribute 'hide'}
    eHomeMode                : E_EpicsHomeCmd := E_EpicsHomeCmd.AUTOZERO;
    {attribute 'hide'}
    eBufferMode              : MC_BufferMode := MC_BufferMode.MC_Aborting;
    {attribute 'hide'}
    eMotionState             : E_MoveState;
    {attribute 'hide'}
    eHomeState               : E_MoveState;
	
	stMCS2ModParams : ST_MCS2ModParams;
    {attribute 'hide'}
    fbMcPower                : MC_Power;
    {attribute 'hide'}
    fbMcMoveAbsolute         : MC_MoveAbsolute;
    {attribute 'hide'}
    fbMcHalt                 : MC_Halt;
    {attribute 'hide'}
    fbMcReset                : MC_Reset;
    {attribute 'hide'}
    fbMcWriteParameter       : MC_WriteParameter;
    {attribute 'hide'}
    fbMcReadParams           : MC_ReadParameterSet;
    {attribute 'hide'}
    bLastHoltTimeOut         : BOOL;
    {attribute 'hide'}
    bEnPosLag                : BOOL;
    {attribute 'hide'}
    bWrongParameter          : BOOL;
    {attribute 'hide'}
    bExecMove                : BOOL;
    {attribute 'hide'}
    bExecHome                : BOOL;
    {attribute 'hide'}
    bNewMoveReq              : BOOL;
    {attribute 'hide'}
    bHomeBusy                : BOOL;
    {attribute 'hide'}
    bPrepareDisable          : BOOL;
    {attribute 'hide'}
    bStepMoveDone            : BOOL;
    {attribute 'hide'}
    bStepMoveBusy            : BOOL;
    {attribute 'hide'}
    bStop                    : BOOL;
    {attribute 'hide'}
    bOperational             : BOOL;
    {attribute 'hide'}
    bLimOverride             : BOOL;
    {attribute 'hide'}
    bPositionHold            : BOOL;
    {attribute 'hide'}
    bLocalExec               : BOOL;
    {attribute 'hide'}
    bSystemInit              : BOOL;
    bHomeDone                : BOOL;
    {attribute 'hide'}
	bCalibrationModeEnabled : BOOL;
    {attribute 'hide'}
    bStepModeEnabled         : BOOL;
    {attribute 'hide'}
    bHomeModeEnabled         : BOOL;
    {attribute 'hide'}
    bCSPModeEnabled          : BOOL;
    {attribute 'hide'}
    bSteModeEnable           : BOOL;
    {attribute 'hide'}
    bRestoreLoad             : BOOL;
    {attribute 'hide'}
    bStepModeParamsSet   : BOOL;
    {attribute 'hide'}
    bExecParamsRead          : BOOL;
    {attribute 'hide'}
    bCommandMoveAbsolute     : BOOL;
    {attribute 'hide'}
    bRecentEnPosLagStatus    : BOOL;
    {attribute 'hide'}
    bDS402ManualAborted      : BOOL;
    {attribute 'hide'}
    bStepMoveAborted         : BOOL;
    {attribute 'hide'}
    bHomeAborted             : BOOL;
    {attribute 'hide'}
    bDS402ManualEnabled      : BOOL;
    {attribute 'hide'}
    bLocalReset              : BOOL;
    {attribute 'hide'}
    nCommandLocal            : INT := 3;
    {attribute 'hide'}
    nCmdDataLocal            : INT;
    {attribute 'hide'}
    bManualTransition        : BOOL;
    // ====== Measurements & scaled values ======
    {attribute 'hide'}
    nScaledFErrWin 		: DINT;
    {attribute 'hide'}
    nScalededSteps  	: DINT;
    {attribute 'hide'}
    fScalededSteps           : LREAL;
    {attribute 'hide'}
    fMeasuredVelo            : LREAL;
    {attribute 'hide'}
    fMeasuredAcc             : LREAL;
    fParameterValue          : LREAL;
    {attribute 'hide'}
    fMeasuredPos             : LREAL;
    // ====== Internal numeric parameters ======
    {attribute 'hide'}
    nScalededStepAmp         : UINT;
    {attribute 'hide'}
    nScaledStepFreq          : UINT;
    // ====== Timer and trigger FBs ======
    {attribute 'hide'}
    tonInitTimer             : TON;
    {attribute 'hide'}
    tonSyncHoming            : TON;
    {attribute 'hide'}
    tonHoldTime              : TON;
    {attribute 'hide'}
    tonSlowParamReadTimer    : TON;
    {attribute 'hide'}
    NCParamsTimer            : TON;
    {attribute 'hide'}
    tonRestoreRetry          : TON;

    {attribute 'hide'}
    rtAborted                : R_TRIG;
    {attribute 'hide'}
    rtStepMoveDone           : R_TRIG;
    {attribute 'hide'}
    rtStopDone               : R_TRIG;
    {attribute 'hide'}
    rtExec                   : R_TRIG;
    {attribute 'hide'}
    rtMoveCmdShortcut        : R_TRIG;
    {attribute 'hide'}
    rtHomeCmdShortcut        : R_TRIG;
    {attribute 'hide'}
    rtEnableMode             : R_TRIG;
    {attribute 'hide'}
    rtUserExec               : R_TRIG;
    {attribute 'hide'}
    rtModeChange             : R_TRIG;
    {attribute 'hide'}
    rtMoveDone               : R_TRIG;
    {attribute 'hide'}
    rtNewMoveReq             : R_TRIG;
    {attribute 'hide'}
    ftExec                   : F_TRIG;
    {attribute 'hide'}
    rtHomeDone               : R_TRIG;
    {attribute 'hide'}
    rtCSPModeOk              : R_TRIG;
    {attribute 'hide'}
    rtHomeModeEnable         : R_TRIG;
    {attribute 'hide'}
    rtStepModeEnabled        : R_TRIG;
    {attribute 'hide'}
    rtNewServoMove           : R_TRIG;
    {attribute 'hide'}
    rtStepMove               : R_TRIG;

    // ====== Channel-specific object indices ======
    nSubIndex                : BYTE := 0;        // Main subindex (which channel)
    {attribute 'hide'}
    nChanFErrWinIdx          : WORD;
    {attribute 'hide'}
    nChanSoftwareLimIdx      : WORD;
    {attribute 'hide'}
    nChanMotorLoadIdx        : WORD;
    {attribute 'hide'}
    nChanErrorCodeIdx        : WORD;
    {attribute 'hide'}
    nChanStepIdx             : WORD;
    {attribute 'hide'}
    nChanStepFreqIdx         : WORD;
    {attribute 'hide'}
    nChanStepAmpIdx          : WORD;
    {attribute 'hide'}
    nChanSoftLimitIdx        : WORD;
    {attribute 'hide'}
    nChanHomeOffsIdx         : WORD;
    {attribute 'hide'}
    nChanHomeVeloIdx         : WORD;
    {attribute 'hide'}
    nChanhomeAccIdx          : WORD;
    {attribute 'hide'}
    nMaxCloseLoopFreqIdx     : WORD;
    {attribute 'hide'}
    nPositionerTypeIdx       : WORD;
    {attribute 'hide'}
    nCalibrationOptIdx       : WORD;
    {attribute 'hide'}
    nSensorPowerModeIdx      : WORD;
    {attribute 'hide'}
    nReferencingOptIdx       : WORD;
    {attribute 'hide'}
    nSafeDirIdx              : WORD;
    {attribute 'hide'}
    nMotorLoadIdx            : WORD;
    {attribute 'hide'}
    nChannelTypeIdx          : WORD;
    {attribute 'hide'}
    nChannelStateIdx         : WORD;
    {attribute 'hide'}
    nLogicalScaleOffsetIdx   : WORD;

	rtStepCmdShortcut: R_TRIG;
	rtCalibrateCmdShortcut: R_TRIG;
	bCommandMoveStep: BOOL;
	bCalibrationsParamsSet: BOOL;
	bHomingParamsSet: BOOL;
	bCalibrateMoveAborted: BOOL;
	bCalibrateMoveDone: BOOL;
END_VAR

VAR CONSTANT
    {attribute 'hide'}
    nChanSoftLimitBase       : WORD := 16#200E;
    {attribute 'hide'}
    nHomeOffsetBase          : WORD := 16#607C;
    {attribute 'hide'}
    nHomingSpeedBase         : WORD := 16#6099;
    {attribute 'hide'}
    nhomingAccBase           : WORD := 16#609A;
    {attribute 'hide'}
    nErrorCodeBase           : WORD := 16#603F;
    {attribute 'hide'}
    nFErrWinBase             : WORD := 16#6065;
    {attribute 'hide'}
    nChanOfsBase             : WORD := 16#800;      // For SmartAct MCS2 and E-727
    {attribute 'hide'}
    nEncErrorCode            : WORD := 16#7300;     // Motor encoder defective code (for save/restore)
    {attribute 'hide'}
    nSoftLimBase             : WORD := 16#200E;
    {attribute 'hide'}
    nOlStepBase              : WORD := 16#2022;
    {attribute 'hide'}
    nOlStepAmpBase           : WORD := 16#2023;
    {attribute 'hide'}
    nOlStepFreqBase          : WORD := 16#2024;
    {attribute 'hide'}
    nMaxCloseLoopFreqBase    : WORD := 16#2001;
    {attribute 'hide'}
    nPositionerTypeBase      : WORD := 16#2000;
    {attribute 'hide'}
    nCalibrationOptBase      : WORD := 16#2004;
    {attribute 'hide'}
    nSensorPowerModeBase     : WORD := 16#2007;
    {attribute 'hide'}
    nReferencingOptBase      : WORD := 16#200B;
    {attribute 'hide'}
    nSafeDirBase             : WORD := 16#200C;
    {attribute 'hide'}
    nMotorLoadBase           : WORD := 16#200D;
    {attribute 'hide'}
    nChannelTypeBase         : WORD := 16#200F;
    {attribute 'hide'}
    nChannelStateBase        : WORD := 16#2025;
    {attribute 'hide'}
    nLogicalScaleOffsetBase  : WORD := 16#2008;
END_VAR

VAR PERSISTENT
    bSaved                   : BOOL;
    fSavedPosition           : LREAL;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF NOT __ISVALIDREF( stMotionStage) THEN
    RETURN;
END_IF

// when the plc autoboot it appears reading from i/o is not yet after 'call_after_init'
IF bSystemInit THEN
    IF  stMotionStage.Axis.NcToPlc.AxisId <> 0 THEN
        stDS402Drive.nDS402DriveControl := 128; // clear errors, prepare for startup
        bExecParamsRead := TRUE; // trigger NC param read on first scan
        bSystemInit := FALSE;
    END_IF
END_IF
(* Check for the plc shortcut commands
   Used for testing or to circumvent motor record issues*)
rtMoveCmdShortcut(CLK:= stMotionStage.bMoveCmd);
rtHomeCmdShortcut(CLK:= stMotionStage.bHomeCmd);
rtStepCmdShortcut(CLK:= stMCS2ModParams.bStepMoveCmd);
rtCalibrateCmdShortcut(CLK:= stMCS2ModParams.bCalibrationCmd);

(* Execute on rising edge*)
IF rtMoveCmdShortcut.Q AND NOT stMotionStage.bExecute THEN
    stMotionStage.bExecute := TRUE;
    stMotionStage.nCommand := E_EpicsMotorCmd.MOVE_ABSOLUTE;
    bEnPosLag := bRecentEnPosLagStatus;
    fParameterValue := BOOL_TO_LREAL(bRecentEnPosLagStatus);

ELSIF rtStepCmdShortcut.Q AND NOT stMotionStage.bExecute THEN
    stMotionStage.bExecute := TRUE;
    stMotionStage.nCommand := E_EpicsMotorCmd.JOG;           // Step mode uses JOG
    nCommandLocal := E_EpicsMotorCmd.JOG;
    bEnPosLag := bRecentEnPosLagStatus;
    fParameterValue := BOOL_TO_LREAL(bRecentEnPosLagStatus);

ELSIF rtCalibrateCmdShortcut.Q AND NOT stMotionStage.bExecute THEN
    stMotionStage.bExecute := TRUE;
    stMotionStage.nCommand := E_EpicsMotorCmd.CALIBRATE;     // Calibration mode uses CALIBRATE
    nCommandLocal := E_EpicsMotorCmd.CALIBRATE;
    bEnPosLag := bRecentEnPosLagStatus;
    fParameterValue := BOOL_TO_LREAL(bRecentEnPosLagStatus);

ELSIF rtHomeCmdShortcut.Q AND NOT stMotionStage.bExecute THEN
    stMotionStage.bExecute := NOT (stMotionStage.nCmdData = E_EpicsHomeCmd.ABSOLUTE_SET)
                             OR NOT (stMotionStage.nCmdData = E_EpicsHomeCmd.NONE);
    stMotionStage.nCommand := E_EpicsMotorCmd.HOME;
    stMotionStage.nCmdData := stMotionStage.nHomingMode;
    IF stMotionStage.stAxisParameters.bCtrlEnablePosDiffControl.0 THEN
        bRecentEnPosLagStatus := stMotionStage.stAxisParameters.bCtrlEnablePosDiffControl.0;
        bEnPosLag := TRUE;
        fParameterValue := 0;
    END_IF
END_IF

(* entry point for local and EPICS main execs *)
rtUserExec(CLK:= stMotionStage.bExecute);
(* if a Move/Home Goal is comfirmed and there is no persistant
   error conditions, then we have a valid move request.*)
bNewMoveReq S= NOT  stMotionStage.bBusy AND rtUserExec.Q AND NOT  stMotionStage.bError;
(* this Move request is valid till an error occurs or the currently move is done *)
bNewMoveReq R= NOT  stMotionStage.bExecute OR  stMotionStage.bError;
bPrepareDisable R= bNewMoveReq;
rtNewMoveReq(CLK:=bNewMoveReq);
(* Moves are automatically allowed if no safety hooks.
   Otherwise, some other code will set this.*)
 stMotionStage.bSafetyReady S=  stMotionStage.bPowerSelf;
(* Set the proper command for the request move;
   if bservo not set, manual step moves will be performed *)
IF rtUserExec.Q THEN
    IF stMotionStage.bHomeCmd OR stMotionStage.bMoveCmd THEN
        // For standard move and home commands
        nCmdDataLocal := stMotionStage.nCmdData;
        nCommandLocal := stMotionStage.nCommand;
    ELSIF stMCS2ModParams.bStepMoveCmd THEN
        // For stepmode, directly write the command
        stMotionStage.nCommand := E_EpicsMotorCmd.JOG;
        nCommandLocal := E_EpicsMotorCmd.JOG;
    ELSIF stMCS2ModParams.bCalibrationCmd THEN
        // For calibration, directly write the command
        stMotionStage.nCommand := E_EpicsMotorCmd.CALIBRATE;
        nCommandLocal := E_EpicsMotorCmd.CALIBRATE;
    END_IF

    IF NOT stMotionStage.bHomeCmd THEN
        // attempting to move an axis without homing first?
        IF stMotionStage.nHomingMode <> E_EpicsHomeCmd.NONE AND NOT stMotionStage.bHomed THEN
            stMotionStage.sErrorMessage := 'Axis homing mode set, but homing routine pending';
        END_IF
    END_IF
END_IF

(* Set the drive in the correct operating mode. based on requested move command!
    NB: bservo must set for close loop motion
*)
ModeOperation();

(* NB: This is the only tested mode of operation so far. also aligned
    piezo drive position holding feature
*)
rtEnableMode(CLK:=( stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION));
(* Handle auto-enable timing *)
CASE  stMotionStage.nEnableMode OF
    (* Not recommended, not tested *)
    E_StageEnableMode.ALWAYS:
         stMotionStage.bEnable:=stMotionStage.bSafetyReady;
    E_StageEnableMode.DURING_MOTION:
        IF rtEnableMode.Q THEN
             stMotionStage.bEnable := FALSE;
        END_IF
        IF rtNewMoveReq.Q THEN
            (* override ongoing holding.*)
            bPositionHold := FALSE;
            tonHoldTime.IN:=FALSE;
            (*MC block are not compatible with open loop Motion
                thus we wathc for correct close loop modes to use NC features *)
             stMotionStage.bEnable S=  stMotionStage.bSafetyReady;
            bLastHoltTimeOut := FALSE;
            bStop:=FALSE;
        END_IF
END_CASE
(*	Interlock mainly react on internal limit conditions inthe ove direction.
    MCS2 drive will go into error state when an internal limit is hit *)
Interlock();

IF bCSPModeEnabled THEN
    bLocalExec := NOT stMotionStage.bError
                  AND stMotionStage.bExecute
                  AND stMotionStage.bAllEnable
                  AND stMotionStage.bEnableDone
                  AND stMotionStage.bSafetyReady
                  AND nCommandLocal = E_EpicsMotorCmd.MOVE_ABSOLUTE;
ELSIF bHomeModeEnabled THEN
    bLocalExec := NOT stMotionStage.bError
                  AND stMotionStage.bExecute
                  AND stMotionStage.bAllEnable
                  AND bOperational
                  AND stMotionStage.bSafetyReady
                  AND nCommandLocal = E_EpicsMotorCmd.HOME;
ELSIF bStepModeEnabled THEN
    bLocalExec := NOT stMotionStage.bError
                  AND stMotionStage.bExecute
                  AND stMotionStage.bAllEnable
                  AND bOperational
                  AND stMotionStage.bSafetyReady
                  AND nCommandLocal = E_EpicsMotorCmd.JOG;
ELSIF bCalibrationModeEnabled THEN
    bLocalExec := NOT stMotionStage.bError
                  AND stMotionStage.bExecute
                  AND stMotionStage.bAllEnable
                  AND bOperational
                  AND stMotionStage.bSafetyReady
                  AND nCommandLocal = E_EpicsMotorCmd.CALIBRATE;
ELSE
    bLocalExec := FALSE;
END_IF

bExecMove:=bLocalExec AND ((nCommandLocal=E_EpicsMotorCmd.MOVE_ABSOLUTE) 
					  OR (nCommandLocal=E_EpicsMotorCmd.JOG)
					  OR (nCommandLocal=E_EpicsMotorCmd.CALIBRATE));
bExecHome:=bLocalExec AND NOT bExecMove;

(* When we start, set the busy/done appropriately
   NB: CLose loop control using NC *)
rtExec(CLK:=bLocalExec);
IF rtExec.Q THEN
    // Release previous interruption if any
    stDS402Drive.nDS402DriveControl.8 := FALSE;
     stMotionStage.bDone := FALSE;
END_IF

(* updated axis status
   Not needed in manual mode *)
IF NOT bDS402ManualEnabled THEN
     stMotionStage.Axis.ReadStatus();
END_IF

(* Get a definitive bEnabled reading
   NB: use only in close loop mode, NC feature needed*)
CASE  stMotionStage.Axis.Status.MotionState OF
    (* We are not enabled if there is an issue*)
    MC_AXISSTATE_UNDEFINED, MC_AXISSTATE_DISABLED, MC_AXISSTATE_ERRORSTOP:
         stMotionStage.bEnableDone := FALSE;
    ELSE
         stMotionStage.bEnableDone := TRUE;
END_CASE
//
IF  stMotionStage.bReset THEN
     stMotionStage.bExecute:=FALSE;
     stMotionStage.bError := FALSE;
     stMotionStage.nErrorId := 0;
     stMotionStage.sErrorMessage:='';
     stMotionStage.sCustomErrorMessage:='';
    (*Manual Drive reset*)
    IF bDS402ManualEnabled THEN
        // Clear error/warning
        bManualTransition:=FALSE;
        IF NOT  stMotionStage.bBusy THEN
            stDS402Drive.nDS402DriveControl := 128;
        ELSE
            // Power off the drive
             stMotionStage.bEnable:=FALSE;
            stDS402Drive.nDS402DriveControl := 6;
        END_IF
    ELSE
        bLocalReset := TRUE;
    END_IF
     stMotionStage.bReset:=FALSE;
END_IF

// Halt is always a user stop during motion
bStop S= NOT bLocalExec AND NOT bLocalReset 
		 AND ((bHomeBusy AND (nCommandLocal=10))
		 OR(fbMcMoveAbsolute.Busy AND (nCommandLocal=3)) 
		 OR (bStepMoveBusy AND (nCommandLocal=0)));

//auto handle position lag monitoring, disable during homing.
WriteParameterNC(	Execute:=bEnPosLag,
                    ParameterNumber:=MC_AxisParameter.AxisEnPositionLagMonitoring,
                    ParameterValue:=fParameterValue);

(* Requested commands processing *)
CASE nCommandLocal OF
    E_EpicsMotorCmd.MOVE_ABSOLUTE:
        (*NC CSP Move Handling*)
        Reset();
        Power();
        Halt();
        (*Wait for drive to be in the correct mode after a request was validated *)
        bCommandMoveAbsolute := bExecMove AND fbMcPower.Status AND bCSPModeEnabled;
        MoveAbsolute();
        (*IN CSP mode the drive control word is update via the NC
          Manual step mode and Homing will override this *)
        stDS402Drive.nDS402DriveControl := stDS402Drive.nDS402DriveControlNC;
    E_EpicsMotorCmd.HOME:
        (*DS402 Manual Homing*)
        Home(Enable:= bExecHome AND bHomingParamsSet AND NOT bWrongParameter );
    E_EpicsMotorCmd.JOG:
        (* Set drive to correct operating mode, ensure motion params are correct
          following a validated open loop mode request.
          NB: bservo must be off. a PV is provided for that
        *)
        StepMove(Enable := bExecMove AND bStepModeParamsSet AND NOT bWrongParameter);
    E_EpicsMotorCmd.CALIBRATE:
        Calibrate(Enable := bExecMove AND bCalibrationsParamsSet AND NOT bWrongParameter); 
END_CASE

stMotionStage.bBusy := fbMcMoveAbsolute.Busy OR stMCS2ModParams.stChannelState.bReferencing OR bStepMoveBusy OR stMCS2ModParams.stChannelState.bCalibrating;

(* Check done moving via user stop, limit hit, Target Position reached, or from homing.*)
rtMoveDone(CLK:=fbMcMoveAbsolute.Done);
rtStepMoveDone(CLK:=bStepMoveDone);
rtHomeDone(CLK:=bHomeDone);
rtStopDone(CLK:=fbMcHalt.Done);
rtAborted(CLK:=bHomeAborted OR bStepMoveAborted);
IF rtAborted.Q OR rtStopDone.Q OR rtMoveDone.Q OR rtHomeDone.Q OR rtStepMoveDone.Q THEN
    IF NOT  stMotionStage.bDone THEN
         stMotionStage.bHomed := bHomeDone;
         stMotionStage.bExecute:=FALSE;
        bCommandMoveAbsolute := FALSE;
         stMotionStage.bDone := fbMcMoveAbsolute.Done OR stMCS2ModParams.stChannelState.bIsReferenced OR bStepMoveDone OR stMCS2ModParams.stChannelState.bIsCalibrated;
        IF bDS402ManualEnabled THEN
            (*Restore Postional lag monitoring*)
            bEnPosLag := FALSE;
        END_IF
        (* Release the internal limit override*)
        bLimOverride := FALSE;
        bHomeAborted := FALSE;
        bStepMoveAborted := FALSE;
    END_IF
END_IF

(* hold stage in place before timeout *)
tonHoldTime(PT:=UDINT_TO_TIME(stMCS2ModParams.nHoldTime));
IF tonHoldTime.Q THEN
    bPositionHold := FALSE;
    tonHoldTime.IN:=FALSE;
    bLastHoltTimeOut := TRUE;
    (* open loop mode is not compatible with MC_Power, MC _Halt...*)
    (* Manual power disabling is required*)
    IF bDS402ManualEnabled THEN
        stDS402Drive.nDS402DriveControl := 6;
    END_IF
     stMotionStage.bEnable:=FALSE;
    bStop := FALSE;
END_IF

(* updated axis status
   Not needed in manual mode *)
IF NOT bDS402ManualEnabled THEN
     stMotionStage.Axis.ReadStatus();
END_IF
//
ftExec(CLK:= stMotionStage.bExecute);
(*Handle auto-disable timing*)
bPrepareDisable S=  stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION AND ftExec.Q;
(* Delay the disable until we reach standstill *)
IF bPrepareDisable AND  stMotionStage.Axis.Status.StandStill THEN
    IF NOT bPositionHold THEN
        bPrepareDisable:=FALSE;
         stMotionStage.bEnable:=FALSE;
    END_IF
END_IF

(* update encoder value and calibrated position*)
ScaleEncRawValue();

(*Drive parameters*)
ExposedParameters(Enable:=TRUE, tRefreshDelay:=T#2S);

(*Sync NC setting to drive settings*)
SetChanParams(
	Enable:= stMotionStage.bAxisParamsInit 
		AND NOT  stMotionStage.bBusy
);

THIS^.SetCalibrationParams(
	Enable:=stMotionStage.bAxisParamsInit 
		AND NOT  stMotionStage.bBusy
		AND bCalibrationModeEnabled
);
THIS^.SetHomingParams(
	Enable:=stMotionStage.bAxisParamsInit 
		AND NOT  stMotionStage.bBusy 
		AND bDS402ManualEnabled
 );
(* Open Loop Motion paramters Update*)
SetJogParams(
	Enable:= stMotionStage.bAxisParamsInit 
		AND NOT  stMotionStage.bBusy
		AND bStepModeEnabled
);

(*Read MCS2 Channel Parameters*)
ReadChanParams();
(* Save and restore as long as not an absolute encoder*)
PersistParameters( Enable:= stMotionStage.nHomingMode <> E_EpicsHomeCmd.NONE);
(*Restore encoder value at initialization*)
RestoreMotionParams(Enable:= stMotionStage.nHomingMode <> E_EpicsHomeCmd.NONE);

(*EPICS Motor record Update*)
SetEpicsStatus();
(*
    Error from functions and Nc. The error will send to EPICS interface based on predifined
    priority: axis, power, backlash, absoluteMove, etc...
*)
IF fbMcPower.Error AND fbMcPower.Active THEN
     stMotionStage.bError:=fbMcPower.Error;
     stMotionStage.nErrorId:=fbMcPower.ErrorID;
ELSIF fbMcMoveAbsolute.Error THEN
     stMotionStage.bError:=fbMcMoveAbsolute.Error;
     stMotionStage.nErrorId:=fbMcMoveAbsolute.ErrorID;
ELSIF fbMcHalt.Error AND fbMcHalt.Active THEN
     stMotionStage.bError:=fbMcHalt.Error;
     stMotionStage.nErrorId:=fbMcHalt.ErrorID;
ELSIF fbMcReset.Error  THEN
     stMotionStage.bError:=fbMcReset.Error;
     stMotionStage.nErrorId:=fbMcReset.ErrorID;
ELSIF fbMcWriteParameter.Error THEN
     stMotionStage.bError:=fbMcWriteParameter.Error;
     stMotionStage.nErrorId:=fbMcWriteParameter.ErrorID;
ELSIF fbMcReadParams.Error AND NOT  stMotionStage.bBusy THEN
     stMotionStage.bError:=fbMcReadParams.Error;
     stMotionStage.nErrorId:=fbMcReadParams.ErrorID;
ELSE
    IF  stMotionStage.bBusy THEN
         stMotionStage.sErrorMessage := '';
         stMotionStage.sCustomErrorMessage := '';
    END_IF
END_IF;

(*Double function, prioritize NC error otherwise read drive channel error code*)
ReadDriveCodes();

IF  stMotionStage.sCustomErrorMessage <> ''
    AND  stMotionStage.sErrorMessage = '' THEN
     stMotionStage.sErrorMessage :=  stMotionStage.sCustomErrorMessage;
END_IF

(*Clear motion flag when error occurs*)
IF  stMotionStage.bError  THEN
     stMotionStage.bBusy := FALSE;
     stMotionStage.bDone := FALSE;
     stMotionStage.bEnable := FALSE;
END_IF

(* We've got the rising edge clear this flags.*)
stMotionStage.bMoveCmd := FALSE;
stMotionStage.bHomeCmd := FALSE;
stMCS2ModParams.bStepMoveCmd := FALSE;
stMCS2ModParams.bCalibrationCmd := FALSE;
]]></ST>
    </Implementation>
    <Method Name="Calibrate" Id="{366a3de7-f782-4695-9a8f-c19bec667315}">
      <Declaration><![CDATA[METHOD PRIVATE Calibrate
VAR_INPUT
    Enable : BOOL;
END_VAR
VAR_INST
	rtCalibrateMove: R_TRIG;
	bCalibrateMoveBusy: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[rtCalibrateMove(CLK:=Enable);
CASE eMotionState OF
    E_MoveState.IDLING:;
        // Motion states
        IF rtCalibrateMove.Q THEN
            bCalibrateMoveBusy := TRUE;
            stMotionStage.bDone:=FALSE;
			stDS402Drive.nDS402DriveControl:=15;
            eMotionState:=E_MoveState.INIT;
        END_IF
    E_MoveState.INIT:
            IF  stMotionStage.bError THEN
                eMotionState:=E_MoveState.ERROR;
			ELSIF stDS402Drive.stDS402DriveStatus.Bit12_OpModeSpecific THEN
				eMotionState:=E_MoveState.REACHED;
            ELSE
                stDS402Drive.nDS402DriveControl:=31;
				eMotionState:=E_MoveState.IN_PROGRESS;
            END_IF

    E_MoveState.IN_PROGRESS:
        IF bStop THEN
            stDS402Drive.nDS402DriveControl.8 :=1;
            bCalibrateMoveAborted := TRUE;
            eMotionState:=E_MoveState.INTERRUPTED;
        ELSIF stDS402Drive.stDS402DriveStatus.Bit13_OpModeSpecific THEN
             stMotionStage.bError := TRUE;
            eMotionState:=E_MoveState.ERROR;
        ELSE
            // Reached ?
            IF stDS402Drive.stDS402DriveStatus.TargetReached
                 AND NOT stDS402Drive.stDS402DriveStatus.Bit12_OpModeSpecific THEN
                eMotionState:=E_MoveState.REACHED;
            END_IF
        END_IF
    E_MoveState.INTERRUPTED:
        IF ( stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION ) THEN
            bPositionHold := TRUE;
            tonHoldTime.IN:=TRUE;
        END_IF
		stDS402Drive.nDS402DriveControl:=15;
        bCalibrateMoveBusy:=FALSE;
        eMotionState:=E_MoveState.IDLING;
    E_MoveState.REACHED:
        // Release the endstop override
        bLimOverride := FALSE;
        bCalibrateMoveBusy:=FALSE;
        IF ( stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION ) THEN
            bPositionHold := TRUE;
            tonHoldTime.IN:=TRUE;
        END_IF
        bCalibrateMoveDone:=TRUE;
        stDS402Drive.nDS402DriveControl:=15;
        IF  stMotionStage.bDone THEN
            eMotionState:=E_MoveState.IDLING;
        END_IF
    E_MoveState.ERROR:
        bCalibrateMoveBusy:=FALSE;
        IF bWrongParameter THEN
             stMotionStage.sCustomErrorMessage:='Invalid motion Parameters';
            bWrongParameter := FALSE;
             stMotionStage.bError := TRUE;
        END_IF
        IF NOT  stMotionStage.bError THEN
            eMotionState:=E_MoveState.IDLING;
        END_IF
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExposedParameters" Id="{bfdcb735-2f35-43ca-9b4a-eca418143c19}">
      <Declaration><![CDATA[METHOD PUBLIC  ExposedParameters
VAR_INPUT
    Enable : BOOL;
    tRefreshDelay: TIME;
END_VAR

VAR_INST
    {attribute 'hide'}
    bParamReadTimer 	: BOOL := TRUE;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Periodic update of NC parameters
NCParamsTimer( IN:=Enable AND NOT bExecParamsRead, PT:=tRefreshDelay);
bExecParamsRead S= NCParamsTimer.Q;
fbMcReadParams(
    Parameter:= stMotionStage.stAxisParameters,
    Axis:= stMotionStage.Axis,
    Execute:= bExecParamsRead );

// Copy axis parameters that we want to expose to the EPICS layer.
 stMotionStage.stAxisParametersExposed.bCtrlEnablePosDiffControl     :=  stMotionStage.stAxisParameters.bCtrlEnablePosDiffControl;
 stMotionStage.stAxisParametersExposed.bEncEnableSoftEndMaxControl   :=  stMotionStage.stAxisParameters.bEncEnableSoftEndMaxControl;
 stMotionStage.stAxisParametersExposed.bEncEnableSoftEndMinControl   :=  stMotionStage.stAxisParameters.bEncEnableSoftEndMinControl;
 stMotionStage.stAxisParametersExposed.fAccelerationMax              :=  stMotionStage.stAxisParameters.fAccelerationMax;
 stMotionStage.stAxisParametersExposed.fCtrlPosDiffMax               :=  stMotionStage.stAxisParameters.fCtrlPosDiffMax;
 stMotionStage.stAxisParametersExposed.fCtrlPosDiffMaxTime           :=  stMotionStage.stAxisParameters.fCtrlPosDiffMaxTime;
 stMotionStage.stAxisParametersExposed.fDecelerationMax              :=  stMotionStage.stAxisParameters.fDecelerationMax;
 stMotionStage.stAxisParametersExposed.fEncSoftEndMax                :=  stMotionStage.stAxisParameters.fEncSoftEndMax;
 stMotionStage.stAxisParametersExposed.fEncSoftEndMin                :=  stMotionStage.stAxisParameters.fEncSoftEndMin;
 stMotionStage.stAxisParametersExposed.fVeloMaximum                  :=  stMotionStage.stAxisParameters.fVeloMaximum;
 stMotionStage.stAxisParametersExposed.fEncOffset               		:=  stMotionStage.stAxisParameters.fEncOffset;
 stMotionStage.stAxisParametersExposed.fEncScaleFactorInternal       :=  stMotionStage.stAxisParameters.fEncScaleFactorInternal;

bExecParamsRead R= fbMcReadParams.Done OR fbMcReadParams.Error;
 stMotionStage.bAxisParamsInit S= fbMcReadParams.Done;]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_Init" Id="{a8134580-303c-4b2f-8942-be52670189d3}">
      <Declaration><![CDATA[//FB_Init is always available implicitly and it is used primarily for initialization.
//The return value is not evaluated. For a specific influence, you can also declare the
//methods explicitly and provide additional code there with the standard initialization
//code. You can evaluate the return value.
METHOD FB_Init: BOOL
VAR_INPUT
    bInitRetains: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInCopyCode: BOOL;  // TRUE: the instance will be copied to the copy code afterward (online change)
    stMotionStage		:	REFERENCE TO ST_MotionStage;
    (*Mandatory must be unique for each MCS2 axis *)
    eModule : E_Module;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.stMotionStage REF= stMotionStage;
THIS^.eModule := eModule;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Halt" Id="{6287ad75-ad53-4d78-9e75-75537e8950c5}">
      <Declaration><![CDATA[METHOD Halt : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMcHalt(
    Axis :=  stMotionStage.Axis,
    Execute := bStop AND bCSPModeEnabled,
    Deceleration :=  stMotionStage.fDeceleration,
    BufferMode := eBufferMode,
);

IF fbMcHalt.Done (*OR fbMcReset.Done*) THEN
    (*Hold the position in close loop before dropping power, a positional drift will occur then*)
    IF ( stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION ) THEN
        bPositionHold := TRUE;
        tonHoldTime.IN:=TRUE;
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Home" Id="{30e09e6f-3e19-461e-88df-b1cd53b15969}">
      <Declaration><![CDATA[METHOD PUBLIC Home
VAR_INPUT
    Enable 				: BOOL;
END_VAR
VAR_INST
	rtHomeMove: R_TRIG;
    fbSetPos: MC_SetPosition;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[rtHomeMove(CLK:=Enable);

CASE eHomeState OF
	// Wait for a rising edge
	E_MoveState.IDLING:
		IF rtHomeMove.Q THEN
			bHomeBusy := TRUE;
			stMotionStage.bDone := FALSE;
			fbSetPos.Options.ClearPositionLag := TRUE;
			stDS402Drive.nDS402DriveControl :=15;
			eHomeState := E_MoveState.INIT;	
		END_IF
    
	E_MoveState.INIT:
		IF  stMotionStage.bError THEN
       		eMotionState:=E_MoveState.ERROR;
		// already referenced?
		ELSIF stDS402Drive.stDS402DriveStatus.Bit12_OpModeSpecific THEN
			eMotionState:=E_MoveState.DONE;
   		ELSE
      		stDS402Drive.nDS402DriveControl:=31;
			eHomeState:=E_MoveState.STARTED;
		END_IF
	E_MoveState.STARTED :
     	// this is a comfirmation that routine is ongoing
     	IF NOT stDS402Drive.stDS402DriveStatus.TargetReached
     	    AND NOT stDS402Drive.stDS402DriveStatus.Bit13_OpModeSpecific THEN
     	    eHomeState:=E_MoveState.IN_PROGRESS;
     	END_IF
    
	E_MoveState.IN_PROGRESS :
		IF bStop THEN
		  stDS402Drive.nDS402DriveControl.8 :=1;
		  bHomeAborted := TRUE;
		  eHomeState:=E_MoveState.INTERRUPTED;
		// Genral Motion error i.e Following error ?
		ELSIF stDS402Drive.stDS402DriveStatus.Bit13_OpModeSpecific
				OR stDS402Drive.stDS402DriveStatus.WarningCondition THEN
			stMotionStage.bError := TRUE;
			eHomeState:=E_MoveState.ERROR;
		// Reached
		ELSIF stDS402Drive.stDS402DriveStatus.TargetReached
			AND stDS402Drive.stDS402DriveStatus.Bit12_OpModeSpecific
			AND NOT stDS402Drive.stDS402DriveStatus.Bit13_OpModeSpecific THEN
		   eHomeState:=E_MoveState.DONE;
		END_IF
		
	E_MoveState.INTERRUPTED:
		IF stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION THEN
        	bPositionHold := TRUE;
        	tonHoldTime.IN:=TRUE;

  		END_IF
		stDS402Drive.nDS402DriveControl :=15;
		bHomeBusy:=FALSE;
		eHomeState:=E_MoveState.IDLING;
		   
	E_MoveState.DONE:
        // Release the endstop override
        bLimOverride := FALSE;
		IF stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION THEN
    		bPositionHold := TRUE;
   			tonHoldTime.IN:=TRUE;
 		END_IF
		bHomeBusy:=FALSE;
		tonSyncHoming.IN := FALSE;
   		bHomeDone:=TRUE;
 		stMotionStage.fPosition:=0.0;
		fbSetPos(
        	Axis:=stMotionStage.Axis,
        	Execute:=TRUE,
        	Position:=stMotionStage.fHomePosition
		);
 		stDS402Drive.nDS402DriveControl := 15;
		eHomeState:=E_MoveState.IDLING;
		
	E_MoveState.ERROR:
    	bHomeDone:=FALSE;
    	bHomeBusy:= FALSE;
    	IF bWrongParameter THEN
    	    stMotionStage.sCustomErrorMessage:='Invalid motion Parameters';
    	    bWrongParameter := FALSE;
    	    stMotionStage.bError := TRUE;
    	END_IF
    	IF NOT stMotionStage.bError THEN
    	    eHomeState:=E_MoveState.IDLING;
    	END_IF
   END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Interlock" Id="{b0516fc0-3ac5-4a37-a4b7-b21194f9b805}">
      <Declaration><![CDATA[METHOD PUBLIC Interlock

VAR_INST
    {attribute 'hide'}
    bPositiveDirection  : BOOL;
    {attribute 'hide'}
    bNegativeDirection  : BOOL;
    {attribute 'hide'}
    ftForwardEnabled  	: F_TRIG;

    {attribute 'hide'}
    ftBackwardEnabled 	: F_TRIG;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Positive or Negative direction
bPositiveDirection:= stMotionStage.bBusy AND  stMotionStage.fPosDiff > 0;
bNegativeDirection:= stMotionStage.bBusy AND  stMotionStage.fPosDiff < 0;

// For SmartAct MCS2 these limit are range and enstop limits. however a single bit in the status is used
// bLimOverride  : act as an override after limit was hit to allow reverse movement
 stMotionStage.bLimitForwardEnable :=  bLimOverride OR NOT( bPositiveDirection AND stDS402Drive.stDS402DriveStatus.InternalLimitActive );
 stMotionStage.bLimitBackwardEnable := bLimOverride OR NOT( bNegativeDirection AND stDS402Drive.stDS402DriveStatus.InternalLimitActive );

// use falling trigger to avoid spaming  sErrorMessage
ftForwardEnabled(CLK:= stMotionStage.bLimitForwardEnable);
ftBackwardEnabled(CLK:= stMotionStage.bLimitBackwardEnable);

IF  NOT bHomeBusy AND ftForwardEnabled.Q THEN
    // Not an error, just a warning
     stMotionStage.sCustomErrorMessage:='Cannot move past positive limit.';
    IF NOT bStepModeEnabled THEN
        bLimOverride := TRUE;
        bStop := TRUE;
    END_IF
END_IF

IF NOT bHomeBusy AND ftBackwardEnabled.Q THEN
    // Not an error, just a warning
     stMotionStage.sCustomErrorMessage:='Cannot move past Negative limit.';
    IF NOT bStepModeEnabled THEN
        bLimOverride := TRUE;
        bStop := TRUE;
    END_IF
END_IF

IF NOT  stMotionStage.bError AND  stMotionStage.bExecute AND NOT  stMotionStage.bUserEnable THEN
     stMotionStage.bError := TRUE;
     stMotionStage.nErrorId := 1;
     stMotionStage.sCustomErrorMessage := 'Move requested, but user enable is disabled!';
END_IF

// Update all enable booleans
SetEnables();]]></ST>
      </Implementation>
    </Method>
    <Method Name="ModeOperation" Id="{101f52ed-fac5-4fd9-b68c-696a0d98bf98}">
      <Declaration><![CDATA[(*Switch the drive mod eof Operation
  Servo On: Profil Positioning or HOME
  Servo Off : STEP mode
*)
METHOD ModeOperation
VAR_INST
    rtCalibrationModeEnable : R_TRIG;      // Rising edge detection for calibration mode
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === Mode detection triggers ===
rtCSPModeOk(CLK := (stDS402Drive.nModeOfOperationDisplay = E_DS402OpMode.CSP));
rtHomeModeEnable(CLK := (stDS402Drive.nModeOfOperationDisplay = E_DS402OpMode.HOME));
rtStepModeEnabled(CLK := (stDS402Drive.nModeOfOperationDisplay = E_DS402OpMode.MCS2_OL_STEP_MODE));
rtCalibrationModeEnable(CLK := (stDS402Drive.nModeOfOperationDisplay = E_DS402OpMode.MCS2_CALIBRATION)); // <--- Calibration trigger

// === Mode enable flags ===
IF rtCSPModeOk.Q THEN
    bCSPModeEnabled := TRUE;
ELSIF rtHomeModeEnable.Q THEN
    bHomeModeEnabled := TRUE;
ELSIF rtStepModeEnabled.Q THEN
    bStepModeEnabled := TRUE;
    stMCS2ModParams.bStepMoveCmd := FALSE;
ELSIF rtCalibrationModeEnable.Q THEN
    bCalibrationModeEnabled := TRUE;
END_IF

// === Manual transitions on user command ===
IF rtUserExec.Q AND stMotionStage.bHomeCmd THEN
    IF (stDS402Drive.nModeOfOperationDisplay <> E_DS402OpMode.HOME) THEN
        stDS402Drive.nModeOfOperation := E_DS402OpMode.HOME;
        IF stDS402Drive.nDS402DriveControl.4 THEN
            stDS402Drive.nDS402DriveControl := 15;
        ELSE
            stDS402Drive.nDS402DriveControl := 128;
        END_IF
        bManualTransition := TRUE;
        bOperational := FALSE;
        bStepModeEnabled := FALSE;
        bCSPModeEnabled := FALSE;
        bCalibrationModeEnabled := FALSE;
    ELSE
        bHomeModeEnabled := TRUE;
    END_IF

ELSIF rtUserExec.Q AND stMCS2ModParams.bStepMoveCmd THEN
    IF (stDS402Drive.nModeOfOperationDisplay <> E_DS402OpMode.MCS2_OL_STEP_MODE) THEN
        stDS402Drive.nModeOfOperation := E_DS402OpMode.MCS2_OL_STEP_MODE;
        stDS402Drive.nDS402DriveControl := 128;
        bOperational := FALSE;
        bCSPModeEnabled := FALSE;
        bHomeModeEnabled := FALSE;
        bCalibrationModeEnabled := FALSE;
    ELSE
        bStepModeEnabled := TRUE;
    END_IF
    bManualTransition := TRUE;

ELSIF rtUserExec.Q AND stMotionStage.bMoveCmd THEN
    IF (stDS402Drive.nModeOfOperationDisplay <> E_DS402OpMode.CSP) THEN
        stDS402Drive.nModeOfOperation := E_DS402OpMode.CSP;
        IF stDS402Drive.nDS402DriveControl.4 THEN
            stDS402Drive.nDS402DriveControl := 15;
        ELSE
            stDS402Drive.nDS402DriveControl := 128;
        END_IF
        bManualTransition := TRUE;
        bHomeModeEnabled := FALSE;
        bStepModeEnabled := FALSE;
        bCalibrationModeEnabled := FALSE;
    ELSE
        bCSPModeEnabled := TRUE;
    END_IF

ELSIF rtUserExec.Q AND stMCS2ModParams.bCalibrationCmd THEN
    IF (stDS402Drive.nModeOfOperationDisplay <> E_DS402OpMode.MCS2_CALIBRATION) THEN
        stDS402Drive.nModeOfOperation := E_DS402OpMode.MCS2_CALIBRATION;
        IF stDS402Drive.nDS402DriveControl.4 THEN
            stDS402Drive.nDS402DriveControl := 15;
        ELSE
            stDS402Drive.nDS402DriveControl := 128;
        END_IF
        bManualTransition := TRUE;
        bOperational := FALSE;
        bStepModeEnabled := FALSE;
        bCSPModeEnabled := FALSE;
        bHomeModeEnabled := FALSE;
    ELSE
        bCalibrationModeEnabled := TRUE;
    END_IF
END_IF

// === Manual enable status - only covers manual modes (not CSP auto mode!) ===
bDS402ManualEnabled := bHomeModeEnabled OR bStepModeEnabled OR bCalibrationModeEnabled;

// === State machine processing remains unchanged ===
StateMachine(Enable := 1);]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveAbsolute" Id="{c9986ba7-a025-4f1a-8312-93dc4112a24c}">
      <Declaration><![CDATA[METHOD PUBLIC  MoveAbsolute
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMcMoveAbsolute(
    Axis :=  stMotionStage.Axis,
    Execute := bCommandMoveAbsolute,
    Position :=  stMotionStage.fPosition,
    Velocity :=  stMotionStage.fVelocity,
    Acceleration :=  stMotionStage.fAcceleration,
    Deceleration :=  stMotionStage.fDeceleration,
    BufferMode := eBufferMode,
);

IF fbMcMoveAbsolute.Done (*OR fbMcReset.Done*) THEN
    (*Hold the position in close loop before dropping power, a positional drift will occur then*)
    IF ( stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION ) THEN
        bPositionHold := TRUE;
        tonHoldTime.IN:=TRUE;
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="PersistParameters" Id="{827e19b0-eb90-45f1-a0f0-e397f2f834ae}">
      <Declaration><![CDATA[METHOD PersistParameters
VAR_INPUT
    Enable	: BOOL;
END_VAR

VAR_INST
    {attribute 'hide'}
    bEncError			: BOOL;

    {attribute 'hide'}
    bRestoreWaitRetry	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Save Encoder position
// needs some pre-conditions to use persistent storage
IF Enable THEN
    // Check ST_MotionStage for an encoder error (range 0x44nn)
    bEncError:=  stMotionStage.Axis.Status.Error AND  (  stMotionStage.Axis.Status.ErrorID  >= 16#4400  AND  stMotionStage.Axis.Status.ErrorID <= 16#44FF );
    // Do not save if we're currently loading or if there is an encoder error
    IF NOT bRestoreLoad AND NOT bEncError AND NOT bRestoreWaitRetry THEN
        fSavedPosition :=  stMotionStage.Axis.NcToPlc.ActPos;
        // This persistent variable lets us check if anything was saved
        // It will be TRUE at startup if we have saved values
        bSaved := TRUE;
        (*
            use this with a timer of a change threshold on the fActPosition
            to trigger a save from this PLC program. otherwise this will be a spamming
            persistence, filling up the disk.
        *)
        //iPersistentDataStorage.TriggerWriteOfPersistentData := bSaveEnabled;
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="PostInit" Id="{7af64fe1-72e2-4a67-9fd4-3933db27c0b4}">
      <Declaration><![CDATA[{attribute 'call_after_init'}
(*	eModule: Mandatory must be unique for each MCS2 axis
    clears startup errors or warnings. the process is completed at run time
    SDO update of Drive and open Loop parameter Indexes based on module number
*)
METHOD PostInit
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* SDO update of Drive and open Loop parameter Indexes based on module number *)
nChanErrorCodeIdx        := nErrorCodeBase         + ((eModule-1) * nChanOfsBase);
nChanFErrWinIdx          := nFErrWinBase           + ((eModule-1) * nChanOfsBase);
nChanSoftLimitIdx        := nChanSoftLimitBase     + ((eModule-1) * nChanOfsBase);
nChanHomeOffsIdx         := nHomeOffsetBase        + ((eModule-1) * nChanOfsBase);
nChanHomeVeloIdx         := nHomingSpeedBase       + ((eModule-1) * nChanOfsBase);
nChanhomeAccIdx          := nhomingAccBase         + ((eModule-1) * nChanOfsBase);
nChanStepIdx             := nOlStepBase            + ((eModule-1) * nChanOfsBase);
nChanStepFreqIdx         := nOlStepFreqBase        + ((eModule-1) * nChanOfsBase);
nChanStepAmpIdx          := nOlStepAmpBase         + ((eModule-1) * nChanOfsBase);
nMaxCloseLoopFreqIdx     := nMaxCloseLoopFreqBase  + ((eModule-1) * nChanOfsBase);
nPositionerTypeIdx       := nPositionerTypeBase    + ((eModule-1) * nChanOfsBase);
nCalibrationOptIdx       := nCalibrationOptBase    + ((eModule-1) * nChanOfsBase);
nSensorPowerModeIdx      := nSensorPowerModeBase   + ((eModule-1) * nChanOfsBase);
nReferencingOptIdx       := nReferencingOptBase    + ((eModule-1) * nChanOfsBase);
nSafeDirIdx              := nSafeDirBase           + ((eModule-1) * nChanOfsBase);
nMotorLoadIdx            := nMotorLoadBase         + ((eModule-1) * nChanOfsBase);
nChannelTypeIdx          := nChannelTypeBase       + ((eModule-1) * nChanOfsBase);
nChannelStateIdx         := nChannelStateBase      + ((eModule-1) * nChanOfsBase);
nLogicalScaleOffsetIdx   := nLogicalScaleOffsetBase+ ((eModule-1) * nChanOfsBase);

bSystemInit := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Power" Id="{f641a677-a472-4a34-a0e0-f26f3662273e}">
      <Declaration><![CDATA[METHOD Power : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMcPower(
    Axis :=  stMotionStage.Axis,
    Enable :=  stMotionStage.bAllEnable AND bCSPModeEnabled,
    Enable_Positive :=  stMotionStage.bAllForwardEnable,
    Enable_Negative :=  stMotionStage.bAllBackwardEnable,
    Override := 100.0,
    BufferMode := eBufferMode
);]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadChanParams" Id="{38e016e1-0871-4b70-80ed-51650e23542a}">
      <Declaration><![CDATA[METHOD PRIVATE ReadChanParams
VAR_INST
    tonSDOReadTrigger          : TON;
    bSDOReadTrigger            : BOOL;
	fbMaxCloseLoopFreqRead     : FB_EcCoESdoRead;
	fbPositionerTypeRead       : FB_EcCoESdoRead;
	fbCalibrationOptRead       : FB_EcCoESdoRead;
	fbSensorPowerModeRead      : FB_EcCoESdoRead;
	fbReferencingOptRead       : FB_EcCoESdoRead;
	fbSafeDirRead              : FB_EcCoESdoRead;
	fbMotorLoadRead            : FB_EcCoESdoRead;
	fbChannelTypeRead          : FB_EcCoESdoRead;
	fbChannelStateRead         : FB_EcCoESdoRead;
	fbLogicalScaleOffsetRead   : FB_EcCoESdoRead;
	
	ftMaxCloseLoopFreqRead      : F_TRIG;
	ftPositionerTypeRead        : F_TRIG;
	ftCalibrationOptRead        : F_TRIG;
	ftSensorPowerModeRead       : F_TRIG;
	ftReferencingOptRead        : F_TRIG;
	ftSafeDirRead               : F_TRIG;
	ftMotorLoadRead             : F_TRIG;
	ftChannelTypeRead           : F_TRIG;
	ftChannelStateRead          : F_TRIG;
	ftLogicalScaleOffsetRead    : F_TRIG;

END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ----- 1s Timer to trigger all SDO reads -----
tonSDOReadTrigger(IN:=TRUE, PT:=T#1s);

IF tonSDOReadTrigger.Q THEN
    tonSDOReadTrigger(IN:=FALSE); // Reset timer; we want a pulse
    bSDOReadTrigger := TRUE;
ELSE
    bSDOReadTrigger := FALSE;
END_IF

// ----- SDO Reads, triggered together on the timer pulse -----

fbMaxCloseLoopFreqRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nMaxCloseLoopFreqIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMCS2ModParams.nMaxCloseLoopFreq),
    cbBufLen    := SIZEOF(stMCS2ModParams.nMaxCloseLoopFreq),
    bExecute    := bSDOReadTrigger
);

fbPositionerTypeRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nPositionerTypeIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMCS2ModParams.nPositionerType),
    cbBufLen    := SIZEOF(stMCS2ModParams.nPositionerType),
    bExecute    := bSDOReadTrigger
);

fbCalibrationOptRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nCalibrationOptIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMCS2ModParams.nCalibrationOpt),
    cbBufLen    := SIZEOF(stMCS2ModParams.nCalibrationOpt),
    bExecute    := bSDOReadTrigger
);

fbSensorPowerModeRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nSensorPowerModeIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMCS2ModParams.nSensorPowerMode),
    cbBufLen    := SIZEOF(stMCS2ModParams.nSensorPowerMode),
    bExecute    := bSDOReadTrigger
);

fbReferencingOptRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nReferencingOptIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMCS2ModParams.nReferencingOpt),
    cbBufLen    := SIZEOF(stMCS2ModParams.nReferencingOpt),
    bExecute    := bSDOReadTrigger
);

fbSafeDirRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nSafeDirIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMCS2ModParams.nSafeDir),
    cbBufLen    := SIZEOF(stMCS2ModParams.nSafeDir),
    bExecute    := bSDOReadTrigger
);

fbMotorLoadRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nMotorLoadIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMCS2ModParams.nMotorLoad),
    cbBufLen    := SIZEOF(stMCS2ModParams.nMotorLoad),
    bExecute    := bSDOReadTrigger
);

fbChannelTypeRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nChannelTypeIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMCS2ModParams.nChannelType),
    cbBufLen    := SIZEOF(stMCS2ModParams.nChannelType),
    bExecute    := bSDOReadTrigger
);

fbChannelStateRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nChannelStateIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMCS2ModParams.stChannelState.dwRaw),
    cbBufLen    := SIZEOF(stMCS2ModParams.stChannelState.dwRaw),
    bExecute    := bSDOReadTrigger
);

fbLogicalScaleOffsetRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nLogicalScaleOffsetIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMCS2ModParams.nLogicalScaleOffset),
    cbBufLen    := SIZEOF(stMCS2ModParams.nLogicalScaleOffset),
    bExecute    := bSDOReadTrigger
);

// --- Error logic: Only act if axis is NOT busy, and SDO read failed ---
ftChannelStateRead(CLK := fbChannelStateRead.bBusy);
IF ftChannelStateRead.Q THEN
    IF NOT fbChannelStateRead.bError THEN
		// After SDO read, decode bits to booleans:
		stMCS2ModParams.stChannelState.bActivelyMoving        := (stMCS2ModParams.stChannelState.dwRaw AND 16#00000001) <> 0;
		stMCS2ModParams.stChannelState.bClosedLoopActive      := (stMCS2ModParams.stChannelState.dwRaw AND 16#00000002) <> 0;
		stMCS2ModParams.stChannelState.bCalibrating           := (stMCS2ModParams.stChannelState.dwRaw AND 16#00000004) <> 0;
		stMCS2ModParams.stChannelState.bReferencing           := (stMCS2ModParams.stChannelState.dwRaw AND 16#00000008) <> 0;
		stMCS2ModParams.stChannelState.bMoveDelayed           := (stMCS2ModParams.stChannelState.dwRaw AND 16#00000010) <> 0;
		stMCS2ModParams.stChannelState.bSensorPresent         := (stMCS2ModParams.stChannelState.dwRaw AND 16#00000020) <> 0;
		stMCS2ModParams.stChannelState.bIsCalibrated          := (stMCS2ModParams.stChannelState.dwRaw AND 16#00000040) <> 0;
		stMCS2ModParams.stChannelState.bIsReferenced          := (stMCS2ModParams.stChannelState.dwRaw AND 16#00000080) <> 0;
		stMCS2ModParams.stChannelState.bEndStopReached        := (stMCS2ModParams.stChannelState.dwRaw AND 16#00000100) <> 0;
		stMCS2ModParams.stChannelState.bRangeLimitReached     := (stMCS2ModParams.stChannelState.dwRaw AND 16#00000200) <> 0;
		stMCS2ModParams.stChannelState.bFollowingLimitReached := (stMCS2ModParams.stChannelState.dwRaw AND 16#00000400) <> 0;
		stMCS2ModParams.stChannelState.bMovementFailed        := (stMCS2ModParams.stChannelState.dwRaw AND 16#00000800) <> 0;
		stMCS2ModParams.stChannelState.bIsStreaming           := (stMCS2ModParams.stChannelState.dwRaw AND 16#00001000) <> 0;
		stMCS2ModParams.stChannelState.bPositionerOverload    := (stMCS2ModParams.stChannelState.dwRaw AND 16#00002000) <> 0;
		stMCS2ModParams.stChannelState.bOverTemperature       := (stMCS2ModParams.stChannelState.dwRaw AND 16#00004000) <> 0;
		stMCS2ModParams.stChannelState.bReferenceMark         := (stMCS2ModParams.stChannelState.dwRaw AND 16#00008000) <> 0;
		stMCS2ModParams.stChannelState.bIsPhased              := (stMCS2ModParams.stChannelState.dwRaw AND 16#00010000) <> 0;
		stMCS2ModParams.stChannelState.bPositionerFault       := (stMCS2ModParams.stChannelState.dwRaw AND 16#00020000) <> 0;
		stMCS2ModParams.stChannelState.bAmplifierEnabled      := (stMCS2ModParams.stChannelState.dwRaw AND 16#00040000) <> 0;
		stMCS2ModParams.stChannelState.bInPosition            := (stMCS2ModParams.stChannelState.dwRaw AND 16#00080000) <> 0;
		stMCS2ModParams.stChannelState.bBrakeEnabled          := (stMCS2ModParams.stChannelState.dwRaw AND 16#00100000) <> 0;
    ELSE
        IF NOT FB_MotionStageMCS2.stMotionStage.bBusy THEN
            // --- Error condition (write your own handling here) ---
            FB_MotionStageMCS2.stMotionStage.bError := TRUE;  // Set your own error flag
            FB_MotionStageMCS2.stMotionStage.sErrorMessage := 'Failed to read ChannelState';
        END_IF
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadDriveCodes" Id="{c8b026c7-a02a-444a-a6c8-2fcd1b30b9c5}">
      <Declaration><![CDATA[(* Read Drive error codes after a motion or fault condition occured *)
METHOD ReadDriveCodes : BOOL
VAR_INST
    {attribute 'hide'}
    fbErrorRead			: FB_EcCoESdoRead;
    {attribute 'hide'}
    nPiezoErrorCode   	: UDINT;
    {attribute 'hide'}
    fbLogError  		: FB_LogMotionError;
    {attribute 'hide'}
    ftErrorReadDone  	: F_TRIG;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbErrorRead( sNetId:= THIS^.stMotionStage.stAxisParameters.sAmsNetId,
             nSlaveAddr:=stDS402Drive.nSlaveAddr,
             nIndex:=nChanErrorCodeIdx,
             nSubIndex :=nSubIndex,
             pDstBuf:= ADR(nPiezoErrorCode),
             cbBufLen:=SIZEOF(nPiezoErrorCode),
             bExecute:= FB_MotionStageMCS2.stMotionStage.bError );

ftErrorReadDone(CLK:=fbErrorRead.bBusy);
IF ftErrorReadDone.Q THEN
    IF 	NOT fbErrorRead.bError AND nPiezoErrorCode <> 0 THEN
        FB_MotionStageMCS2.stMotionStage.nErrorId := nPiezoErrorCode;
    END_IF
    FB_MotionStageMCS2.stMotionStage.sErrorMessage := F_MotionErrorCodeLookup(nErrorId:=FB_MotionStageMCS2.stMotionStage.nErrorId);
    fbLogError( stMotionStage:=FB_MotionStageMCS2.stMotionStage, bEnable:=FB_MotionStageMCS2.stMotionStage.bError);
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Reset" Id="{643b4736-0a43-4a18-8f6b-8a2439ed5e6f}">
      <Declaration><![CDATA[METHOD Reset : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMcReset(
    Axis :=  stMotionStage.Axis,
    Execute := bLocalReset AND bCSPModeEnabled
);

IF fbMcReset.Done OR fbMcReset.Error THEN
    bLocalReset := FALSE;
    IF ( stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION ) THEN
         stMotionStage.bEnable:=FALSE;
    END_IF

END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="RestoreMotionParams" Id="{8335d215-fac8-43bf-97f2-e08acc164700}">
      <Declaration><![CDATA[METHOD RestoreMotionParams
VAR_INPUT
    Enable	: BOOL;
END_VAR

VAR_INST
    {attribute 'hide'}
    fbSetPos			: MC_SetPosition;
    {attribute 'hide'}
    bLoad				: BOOL;
    {attribute 'hide'}
    bRestoreDone 		: BOOL;
    {attribute 'hide'}
    bRestoreInit		: BOOL;
    {attribute 'hide'}
    bRestoreWaitRetry	: BOOL;
    {attribute 'hide'}
    nMaxRetries			: UINT := 10;
    {attribute 'hide'}
    nCurrTries			: UINT := 0;
    {attribute 'hide'}
    nLatchError			: UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Enable THEN
    // Trigger a load if anything was saved at all
    IF NOT bRestoreInit THEN
        bRestoreInit := TRUE;
        bRestoreLoad S= bSaved;
        fbSetPos.Options.ClearPositionLag := TRUE;
    END_IF

    // Set our position if bRestoreLoad is true
    fbSetPos( Axis:= stMotionStage.Axis, Execute:=bRestoreLoad, Position:=fSavedPosition);

    // Only load once, at startup
    bRestoreLoad R= fbSetPos.Done OR fbSetPos.Error;

    IF fbSetPos.Error THEN
        // Keep the error latched, it can disappear if Execute is set to FALSE
        nLatchError := fbSetPos.ErrorID;
        nCurrTries := nCurrTries + 1;
        IF nCurrTries >= nMaxRetries THEN
        // Alert the user that something has gone wrong
         stMotionStage.bError := TRUE;
         stMotionStage.nErrorId := nLatchError;
         stMotionStage.sCustomErrorMessage := 'Error loading previously saved position.';
        ELSE
            // Reset the FB for the next retry
            fbSetPos( Axis:= stMotionStage.Axis, Execute:=bRestoreLoad, Position:=fSavedPosition);
            // Try again
            bRestoreWaitRetry := TRUE;
        END_IF
    ELSE
        IF NOT bRestoreDone THEN
             stMotionStage.fPosition := fSavedPosition;
        END_IF
        bRestoreDone := TRUE;
    END_IF

    tonRestoreRetry( IN := bRestoreWaitRetry, PT := T#100MS);
    bRestoreLoad S= tonRestoreRetry.Q;
    bRestoreWaitRetry R= tonRestoreRetry.Q;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ScaleDriveParams" Id="{b413f5fa-ba01-446e-8e58-be0ddf41b7f7}">
      <Declaration><![CDATA[METHOD ScaleDriveParams
]]></Declaration>
      <Implementation>
        <ST><![CDATA[nScaledFErrWin:=LREAL_TO_DINT(( stMotionStage.stAxisParameters.fCtrlPosDiffMax / MAX( stMotionStage.stAxisParameters.fEncScaleFactorInternal, stMCS2ModParams.fScalingFactor)));

IF  stMotionStage.stAxisParameters.bEncEnableSoftEndMinControl.0 AND  stMotionStage.stAxisParameters.bEncEnableSoftEndMaxControl.0 THEN
    stMCS2ModParams.nSoftLimMax := LREAL_TO_DINT(( stMotionStage.stAxisParameters.fEncSoftEndMax / MAX( stMotionStage.stAxisParameters.fEncScaleFactorInternal, stMCS2ModParams.fScalingFactor)));
    stMCS2ModParams.nSoftLimMin := LREAL_TO_DINT(( stMotionStage.stAxisParameters.fEncSoftEndMin / MAX( stMotionStage.stAxisParameters.fEncScaleFactorInternal, stMCS2ModParams.fScalingFactor)));
ELSE
    // Soft limit disabled
    stMCS2ModParams.nSoftLimMax := 0;
    stMCS2ModParams.nSoftLimMin := 0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ScaleEncRawValue" Id="{769f98a6-388a-461f-854a-93b1758d578f}">
      <Declaration><![CDATA[METHOD ScaleEncRawValue
VAR_INPUT
  //  bEnable: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* SmartACT: The encoder count from the Piezo drive is not a raw count from the embeded actuator device
   we get a calibrated nm value. thus the use of abs() since this value is signed.
   PI: to be discovered *)
IF  stMotionStage.nRawEncoderDINT <> 0 THEN
     stMotionStage.nEncoderCount:=DINT_TO_UDINT(ABS( stMotionStage.nRawEncoderDINT));
ELSE
     stMotionStage.nEncoderCount:=0;
END_IF

// calibrated encoder readback
IF NOT bStepModeEnabled THEN
    // Close loop NC
    fMeasuredPos:= stMotionStage.Axis.NcToPlc.ActPos;
    fMeasuredVelo := stMotionStage.Axis.NcToPlc.ActVelo;
    fMeasuredAcc :=  stMotionStage.Axis.NcToPlc.ActAcc;
     stMotionStage.fPosDiff:= stMotionStage.Axis.NcToPlc.PosDiff;
ELSE
    fMeasuredPos:=DINT_TO_REAL( stMotionStage.nRawEncoderDINT) * MAX( stMotionStage.stAxisParameters.fEncScaleFactorInternal, fScalingFactor);
     stMotionStage.fPosDiff:= stMotionStage.fPosition - fMeasuredPos;
    // NB: Not actual in open loop
    fMeasuredVelo := stMotionStage.fVelocity;
    fMeasuredAcc :=  stMotionStage.fAcceleration;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="ScaleHomingParams" Id="{2c5b56b0-7eaa-4a13-8084-de781b4be994}">
      <Declaration><![CDATA[(*Scale Home Move parameters*)
METHOD ScaleHomingParams
]]></Declaration>
      <Implementation>
        <ST><![CDATA[stMCS2ModParams.nHomeVeloFast := LREAL_TO_UDINT(( stMotionStage.stAxisParameters.fRefVeloSearch / MAX( stMotionStage.stAxisParameters.fEncScaleFactorInternal, stMCS2ModParams.fScalingFactor)));
stMCS2ModParams.nHomeVeloSlow := LREAL_TO_UDINT(( stMotionStage.stAxisParameters.fRefVeloSync / MAX( stMotionStage.stAxisParameters.fEncScaleFactorInternal, stMCS2ModParams.fScalingFactor)));
stMCS2ModParams.nHomeAcc := LREAL_TO_UDINT((stMCS2ModParams.fHomeAcc / MAX( stMotionStage.stAxisParameters.fEncScaleFactorInternal, stMCS2ModParams.fScalingFactor)));
stMCS2ModParams.nHomeOffset := LREAL_TO_DINT(( stMotionStage.fHomePosition / MAX( stMotionStage.stAxisParameters.fEncScaleFactorInternal, stMCS2ModParams.fScalingFactor)));
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ScaleJogParams" Id="{78ce5a79-ef3b-44af-a794-7ac04154475b}">
      <Declaration><![CDATA[(*Scaled Open Loop Step mode motion parameters*)
METHOD ScaleJogParams
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF 	stMCS2ModParams.nChanStepAmp = 0
    OR stMCS2ModParams.nChanStepFreq = 0 THEN
    bWrongParameter := TRUE;
ELSE
    fScalededSteps := (THIS^.stMotionStage.fPosition * stMCS2ModParams.nChanStepEgu) ;
    nScalededSteps:=LIMIT(-1000, LREAL_TO_DINT(fScalededSteps), 1000);
    nScalededStepAmp:=REAL_TO_UINT(LIMIT(50, stMCS2ModParams.nChanStepAmp, 100) * 655.35);
    nScaledStepFreq:=REAL_TO_UINT(LIMIT(500, stMCS2ModParams.nChanStepFreq, 1000.0));
    bWrongParameter := FALSE;
END_IF
//827.31x-837.63]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetCalibrationParams" Id="{ca87540c-56e0-4ac6-9006-f00c40b88117}">
      <Declaration><![CDATA[METHOD SetCalibrationParams
VAR_INPUT
    Enable : BOOL;
END_VAR
VAR_INST
    {attribute 'hide'}
    fbSafeDirWrite              : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbChannelTypeWrite          : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbPositionerTypeWrite       : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbCalibrationOptWrite       : FB_EcCoESdoWrite;
    {attribute 'hide'}
    ftPositionerTypeSetDone     : F_TRIG;
    {attribute 'hide'}
    ftCalibrationOptSetDone     : F_TRIG;
    {attribute 'hide'}
    ftSafeDirSetDone            : F_TRIG;
    {attribute 'hide'}
    ftChannelTypeSetDone        : F_TRIG;
    {attribute 'hide'}
    nRecentPositionerType       : UDINT;
    {attribute 'hide'}
    nRecentCalibrationOpt       : UDINT;
    {attribute 'hide'}
    nRecentSafeDir              : BOOL;
    {attribute 'hide'}
    nRecentChannelType          : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Enable THEN
    fbPositionerTypeWrite(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nPositionerTypeIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(stMCS2ModParams.nPositionerType),
        cbBufLen   := SIZEOF(stMCS2ModParams.nPositionerType),
        bExecute   := NOT stMCS2ModParams.stChannelState.bIsCalibrated AND (stMCS2ModParams.nPositionerType <> nRecentPositionerType)
    );
    fbCalibrationOptWrite(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nCalibrationOptIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(stMCS2ModParams.nCalibrationOpt),
        cbBufLen   := SIZEOF(stMCS2ModParams.nCalibrationOpt),
        bExecute   := NOT stMCS2ModParams.stChannelState.bIsCalibrated AND (stMCS2ModParams.nCalibrationOpt  <> nRecentCalibrationOpt)
    );	
    fbSafeDirWrite(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nSafeDirIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(stMCS2ModParams.nSafeDir),
        cbBufLen   := SIZEOF(stMCS2ModParams.nSafeDir),
        bExecute   := NOT stMCS2ModParams.stChannelState.bIsReferenced AND NOT stMCS2ModParams.stChannelState.bIsCalibrated  AND (stMCS2ModParams.nSafeDir <> nRecentSafeDir)
    );
    fbChannelTypeWrite(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nChannelTypeIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(stMCS2ModParams.nChannelType),
        cbBufLen   := SIZEOF(stMCS2ModParams.nChannelType),
        bExecute   := NOT stMCS2ModParams.stChannelState.bIsCalibrated AND (stMCS2ModParams.nChannelType  <> nRecentChannelType)
    );
    ftPositionerTypeSetDone(CLK:=fbPositionerTypeWrite.bBusy);
    ftCalibrationOptSetDone(CLK:=fbCalibrationOptWrite.bBusy);
    ftSafeDirSetDone(CLK:=fbSafeDirWrite.bBusy);
    ftChannelTypeSetDone(CLK:=fbChannelTypeWrite.bBusy);
	
	bCalibrationsParamsSet  R= fbPositionerTypeWrite.bBusy OR fbCalibrationOptWrite.bBusy OR fbSafeDirWrite.bBusy OR fbChannelTypeWrite.bBusy;
	
    IF ftPositionerTypeSetDone.Q OR ftCalibrationOptSetDone.Q  OR ftSafeDirSetDone.Q  OR ftChannelTypeSetDone.Q THEN
        IF fbPositionerTypeWrite.bError THEN
			 stMotionStage.bError := fbPositionerTypeWrite.bError;
			 stMotionStage.nErrorId := fbPositionerTypeWrite.nErrId;
        ELSIF fbCalibrationOptWrite.bError THEN
			 stMotionStage.bError := fbCalibrationOptWrite.bError;
			 stMotionStage.nErrorId := fbCalibrationOptWrite.nErrId;
        ELSIF fbSafeDirWrite.bError THEN
			 stMotionStage.bError := fbSafeDirWrite.bError;
			 stMotionStage.nErrorId := fbSafeDirWrite.nErrId;
        ELSIF fbChannelTypeWrite.bError THEN
			 stMotionStage.bError := fbChannelTypeWrite.bError;
			 stMotionStage.nErrorId := fbChannelTypeWrite.nErrId;
		ELSE
			nRecentSafeDir   		 := stMCS2ModParams.nSafeDir;
			nRecentChannelType       := stMCS2ModParams.nChannelType;
			nRecentPositionerType    := stMCS2ModParams.nPositionerType;
			nRecentCalibrationOpt    := stMCS2ModParams.nCalibrationOpt;
			bCalibrationsParamsSet S= TRUE;
		END_IF
		fbPositionerTypeWrite.bExecute := FALSE;
		fbCalibrationOptWrite.bExecute := FALSE;
		fbSafeDirWrite.bExecute := FALSE;
		fbChannelTypeWrite.bExecute := FALSE;
	 END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetChanParams" Id="{bba7eb59-9b08-4212-8ebb-7515fbf84d2c}">
      <Declaration><![CDATA[(*	Drive parameters update
    Mirror NC axis parameters configurations to those of MCS2 drive
    1- Following error
    2- Home Speeds
    3- Home Acceleration
    4- SoftLimits
*)
METHOD SetChanParams
VAR_INPUT
    Enable : BOOL;
END_VAR

VAR_INST
    {attribute 'hide'}
    fbSetFErrorWin              : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbSetSoftLimMin             : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbSetSoftLimMax             : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbMaxCloseLoopFreqWrite     : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbSensorPowerModeWrite      : FB_EcCoESdoWrite;
    // Existing recent value tracking
    {attribute 'hide'}
    nRecentSoftLimMax           : LINT;
    {attribute 'hide'}
    nRecentSoftLimMin           : LINT;
    {attribute 'hide'}
    nRecentFErrWin              : DINT;
    // Add missing variables for other channel parameters
    {attribute 'hide'}
    nRecentMaxCloseLoopFreq     : UDINT;
    {attribute 'hide'}
    nRecentSensorPowerMode      : UDINT;
    // F_TRIG instances to detect write done for each channel param
    {attribute 'hide'}
    ftFErrWinSetDone            : F_TRIG;
    {attribute 'hide'}
    ftSoftLimMaxSetDone         : F_TRIG;
    {attribute 'hide'}
    ftSoftLimMinSetDone         : F_TRIG;
    // Add triggers for new parameters (if you plan to use them)
    {attribute 'hide'}
    ftMaxCloseLoopFreqSetDone   : F_TRIG;
    {attribute 'hide'}
    ftSensorPowerModeSetDone    : F_TRIG;

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Enable THEN

    (*	Drive parameters update
        Mirror NC axis parameters configurations to those of MCS2 drive
        1- Following error.
        2- SoftLimits
        3-Position Range
    *)
    ScaleDriveParams();
    // 1. Main drive SDO writes
    fbSetFErrorWin(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nChanFErrWinIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(nScaledFErrWin),
        cbBufLen   := SIZEOF(nScaledFErrWin),
        bExecute   := (nScaledFErrWin <> nRecentFErrWin)
    );
    fbSetSoftLimMin(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nChanSoftLimitIdx,
        nSubIndex  := 1,
        pSrcBuf    := ADR(stMCS2ModParams.nSoftLimMin),
        cbBufLen   := SIZEOF(stMCS2ModParams.nSoftLimMin),
        bExecute   := (stMCS2ModParams.nSoftLimMin <> nRecentSoftLimMin)
    );
    fbSetSoftLimMax(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nChanSoftLimitIdx,
        nSubIndex  := 2,
        pSrcBuf    := ADR(stMCS2ModParams.nSoftLimMax),
        cbBufLen   := SIZEOF(stMCS2ModParams.nSoftLimMax),
        bExecute   := (stMCS2ModParams.nSoftLimMax <> nRecentSoftLimMax)
    );
    // 2. Extended parameters SDO writes
    fbMaxCloseLoopFreqWrite(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nMaxCloseLoopFreqIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(stMCS2ModParams.nMaxCloseLoopFreq),
        cbBufLen   := SIZEOF(stMCS2ModParams.nMaxCloseLoopFreq),
        bExecute   := (stMCS2ModParams.nMaxCloseLoopFreq <> nRecentMaxCloseLoopFreq)
    );
    fbSensorPowerModeWrite(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nSensorPowerModeIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(stMCS2ModParams.nSensorPowerMode),
        cbBufLen   := SIZEOF(stMCS2ModParams.nSensorPowerMode),
        bExecute   := (stMCS2ModParams.nSensorPowerMode <> nRecentSensorPowerMode)
    );
    // 3. Rising edge triggers for each param
    ftFErrWinSetDone(CLK:=fbSetFErrorWin.bBusy);
    ftSoftLimMaxSetDone(CLK:=fbSetSoftLimMax.bBusy);
    ftSoftLimMinSetDone(CLK:=fbSetSoftLimMin.bBusy);
    ftMaxCloseLoopFreqSetDone(CLK:=fbMaxCloseLoopFreqWrite.bBusy);
    ftSensorPowerModeSetDone(CLK:=fbSensorPowerModeWrite.bBusy);

    IF ftFErrWinSetDone.Q OR ftSoftLimMaxSetDone.Q OR ftSoftLimMinSetDone.Q
        OR ftMaxCloseLoopFreqSetDone.Q 
        OR ftSensorPowerModeSetDone.Q THEN

        // Error logic for all parameters (set error and id if any)
        IF fbSetFErrorWin.bError THEN
			 stMotionStage.bError := fbSetFErrorWin.bError;
			 stMotionStage.nErrorId := fbSetFErrorWin.nErrId;
        ELSIF fbSetSoftLimMin.bError THEN
			 stMotionStage.bError := fbSetSoftLimMin.bError;
			 stMotionStage.nErrorId := fbSetSoftLimMin.nErrId;
        ELSIF fbSetSoftLimMax.bError THEN
			 stMotionStage.bError := fbSetSoftLimMax.bError;
			 stMotionStage.nErrorId := fbSetSoftLimMax.nErrId;
        ELSIF fbMaxCloseLoopFreqWrite.bError THEN
			 stMotionStage.bError := fbMaxCloseLoopFreqWrite.bError;
			 stMotionStage.nErrorId := fbMaxCloseLoopFreqWrite.nErrId;
        ELSIF fbSensorPowerModeWrite.bError THEN
			 stMotionStage.bError := fbSensorPowerModeWrite.bError;
			 stMotionStage.nErrorId := fbSensorPowerModeWrite.nErrId;
        ELSE
			nRecentFErrWin   		 := nScaledFErrWin;
			nRecentSoftLimMax        := stMCS2ModParams.nSoftLimMax;
			nRecentSoftLimMin        := stMCS2ModParams.nSoftLimMin;
			nRecentMaxCloseLoopFreq  := stMCS2ModParams.nMaxCloseLoopFreq;
			nRecentSensorPowerMode   := stMCS2ModParams.nSensorPowerMode;
        END_IF
        fbSetFErrorWin.bExecute   := FALSE;
        fbSetSoftLimMin.bExecute  := FALSE;
        fbSetSoftLimMax.bExecute  := FALSE;
        fbMaxCloseLoopFreqWrite.bExecute  := FALSE;
        fbSensorPowerModeWrite.bExecute   := FALSE;
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetEnables" Id="{28f7e94e-bad4-40ca-b34a-f8da453343cc}">
      <Declaration><![CDATA[METHOD SetEnables
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ stMotionStage.bAllForwardEnable:= stMotionStage.bLimitForwardEnable AND ( stMotionStage.bGantryForwardEnable OR NOT  stMotionStage.bGantryAxis) AND  stMotionStage.stEPSForwardEnable.bEPS_OK  AND  stMotionStage.bOverrideDirEnable;
 stMotionStage.bAllBackwardEnable:= stMotionStage.bLimitBackwardEnable AND ( stMotionStage.bGantryBackwardEnable OR NOT  stMotionStage.bGantryAxis) AND  stMotionStage.stEPSBackwardEnable.bEPS_OK  AND  stMotionStage.bOverrideDirEnable;

 stMotionStage.bAllEnable:= stMotionStage.bEnable AND  stMotionStage.bHardwareEnable AND  stMotionStage.stEPSPowerEnable.bEPS_OK;
 stMotionStage.bAllEnable R= NOT  stMotionStage.bUserEnable;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetEpicsStatus" Id="{dc90c8f8-9d88-4ab9-9dc0-f90cd21b81fc}">
      <Declaration><![CDATA[METHOD SetEpicsStatus
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//////////////////////////////////////////////////////////////////
// Transfer NC parameter status to EPICS
//////////////////////////////////////////////////////////////////
 stMotionStage.nMotionAxisID :=  stMotionStage.Axis.NcToPlc.AxisId;
 stMotionStage.stAxisStatus.bEnable:= stMotionStage.bAllEnable;
 stMotionStage.stAxisStatus.bEnabled:= stMotionStage.bEnableDone; // account for PowerEnable from power block
 stMotionStage.stAxisStatus.bError:= stMotionStage.bError;
 stMotionStage.stAxisStatus.bHomeSensor:= stMotionStage.bHome;
 stMotionStage.stAxisStatus.bLimitBwd:= stMotionStage.bAllBackwardEnable;
 stMotionStage.stAxisStatus.bLimitFwd:= stMotionStage.bAllForwardEnable;
 stMotionStage.stAxisStatus.bReset:= stMotionStage.bReset;
 stMotionStage.stAxisStatus.fAcceleration:=fMeasuredAcc;
 stMotionStage.stAxisStatus.fActDiff:= stMotionStage.fPosDiff;
 stMotionStage.stAxisStatus.fActPosition:=fMeasuredPos;
 stMotionStage.stAxisStatus.fActVelocity:=fMeasuredVelo;
 stMotionStage.stAxisStatus.fDeceleration:=fMeasuredAcc;
 stMotionStage.stAxisStatus.fOverride:=fbMcPower.Override;
 stMotionStage.stAxisStatus.fPosition:= stMotionStage.fPosition;
 stMotionStage.stAxisStatus.fVelocity:= stMotionStage.fVelocity;
 stMotionStage.stAxisStatus.nCmdData:=INT_TO_UINT( stMotionStage.nCmdData);  //Or nCmdDataLocal
 stMotionStage.stAxisStatus.nCommand:=INT_TO_UINT( stMotionStage.nCommand);  //Or nCommandLocal
 stMotionStage.stAxisStatus.nErrorId:= stMotionStage.nErrorId;
 stMotionStage.stAxisStatus.bBusy:= stMotionStage.bBusy;
 stMotionStage.stAxisStatus.bHomed:= stMotionStage.bHomed;
 stMotionStage.stAxisStatus.bExecute:=bLocalExec;
 stMotionStage.stAxisStatus.nCommand:=3; // If this is not 3, the IOC stops updating positions during homing


]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetHomingParams" Id="{5f7d28d4-6499-4637-aa98-e69b72a3a9cb}">
      <Declaration><![CDATA[METHOD SetHomingParams : BOOL
VAR_INPUT
    Enable : BOOL;
END_VAR

VAR_INST
    {attribute 'hide'}
    fbSetHomeOffs               : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbSetHomeVeloFast           : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbSetHomeVeloSlow           : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbSetHomeAcc                : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbReferencingOptWrite       : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbLogicalScaleOffsetWrite   : FB_EcCoESdoWrite;	
    {attribute 'hide'}
    ftHomeVeloFastSetDone       : F_TRIG;
    {attribute 'hide'}
    ftHomeAccSetDone            : F_TRIG;
    {attribute 'hide'}
    ftHomeOffsSetDone           : F_TRIG;
    {attribute 'hide'}
    ftHomeVeloSlowSetDone       : F_TRIG;
    {attribute 'hide'}
    ftReferencingOptSetDone     : F_TRIG;
    {attribute 'hide'}
    ftLogicalScaleOffsetSetDone : F_TRIG;
    {attribute 'hide'}
    nRecentHomeVeloFast         : UDINT;
    {attribute 'hide'}
    nRecentHomeVeloSlow         : UDINT;
    {attribute 'hide'}
    nRecentHomeAcc              : UDINT;
    {attribute 'hide'}
    nRecentHomeOffset           : DINT;
    {attribute 'hide'}
    nRecentReferencingOpt       : UDINT;
    {attribute 'hide'}
    nRecentLogicalScaleOffset   : LINT; 
    {attribute 'hide'}
    nHomeOffs                   : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Enable THEN
    ScaleHomingParams();

    fbSetHomeVeloFast(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nChanHomeVeloIdx,
        nSubIndex  := 1,
        pSrcBuf    := ADR(stMCS2ModParams.nHomeVeloFast),
        cbBufLen   := SIZEOF(stMCS2ModParams.nHomeVeloFast),
        bExecute   := (stMCS2ModParams.nHomeVeloFast <> nRecentHomeVeloFast)
    );
    fbSetHomeVeloSlow(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nChanHomeVeloIdx,
        nSubIndex  := 2,
        pSrcBuf    := ADR(stMCS2ModParams.nHomeVeloSlow),
        cbBufLen   := SIZEOF(stMCS2ModParams.nHomeVeloSlow),
        bExecute   := (stMCS2ModParams.nHomeVeloSlow <> nRecentHomeVeloSlow)
    );
    fbSetHomeAcc(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nChanhomeAccIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(stMCS2ModParams.nHomeAcc),
        cbBufLen   := SIZEOF(stMCS2ModParams.nHomeAcc),
        bExecute   := (stMCS2ModParams.nHomeAcc <> nRecentHomeAcc)
    );
    fbSetHomeOffs(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nChanHomeOffsIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(stMCS2ModParams.nHomeOffset),
        cbBufLen   := SIZEOF(stMCS2ModParams.nHomeOffset),
        bExecute   := (stMCS2ModParams.nHomeOffset <> nRecentHomeOffset)
    );
    fbReferencingOptWrite(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nReferencingOptIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(stMCS2ModParams.nReferencingOpt),
        cbBufLen   := SIZEOF(stMCS2ModParams.nReferencingOpt),
        bExecute   := NOT stMCS2ModParams.stChannelState.bIsReferenced AND (stMCS2ModParams.nReferencingOpt <> nRecentReferencingOpt)
    );
    fbLogicalScaleOffsetWrite(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nLogicalScaleOffsetIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(stMCS2ModParams.nLogicalScaleOffset),
        cbBufLen   := SIZEOF(stMCS2ModParams.nLogicalScaleOffset),
        bExecute   := (stMCS2ModParams.nLogicalScaleOffset <> nRecentLogicalScaleOffset)
    );

    ftHomeVeloFastSetDone(CLK:=fbSetHomeVeloFast.bBusy);
    ftHomeVeloSlowSetDone(CLK:=fbSetHomeVeloSlow.bBusy);
    ftHomeAccSetDone(CLK:=fbSetHomeAcc.bBusy);
    ftHomeOffsSetDone(CLK:=fbSetHomeOffs.bBusy);
    ftReferencingOptSetDone(CLK:=fbReferencingOptWrite.bBusy);
    ftLogicalScaleOffsetSetDone(CLK:=fbLogicalScaleOffsetWrite.bBusy);

	bHomingParamsSet  R= fbSetHomeVeloFast.bBusy OR fbSetHomeVeloSlow.bBusy OR fbSetHomeAcc.bBusy OR fbSetHomeOffs.bBusy OR fbReferencingOptWrite.bBusy OR fbLogicalScaleOffsetWrite.bBusy;
	
    IF ftHomeVeloFastSetDone.Q OR ftHomeVeloSlowSetDone.Q OR ftHomeAccSetDone.Q OR ftHomeOffsSetDone.Q
		 OR ftReferencingOptSetDone.Q OR ftLogicalScaleOffsetSetDone.Q THEN

        // Error logic for all parameters (set error and id if any)
        IF fbSetHomeVeloFast.bError THEN
			 stMotionStage.bError := fbSetHomeVeloFast.bError;
			 stMotionStage.nErrorId := fbSetHomeVeloFast.nErrId;
        ELSIF fbSetHomeVeloSlow.bError THEN
			 stMotionStage.bError := fbSetHomeVeloSlow.bError;
			 stMotionStage.nErrorId := fbSetHomeVeloSlow.nErrId;
        ELSIF fbSetHomeAcc.bError THEN
			 stMotionStage.bError := fbSetHomeAcc.bError;
			 stMotionStage.nErrorId := fbSetHomeAcc.nErrId;
        ELSIF fbSetHomeOffs.bError THEN
			 stMotionStage.bError := fbSetHomeOffs.bError;
			 stMotionStage.nErrorId := fbSetHomeOffs.nErrId;
        ELSIF fbReferencingOptWrite.bError THEN
			 stMotionStage.bError := fbReferencingOptWrite.bError;
			 stMotionStage.nErrorId := fbReferencingOptWrite.nErrId;
        ELSIF fbLogicalScaleOffsetWrite.bError THEN
			 stMotionStage.bError := fbLogicalScaleOffsetWrite.bError;
			 stMotionStage.nErrorId := fbLogicalScaleOffsetWrite.nErrId;
        ELSE
			nRecentHomeVeloFast      := stMCS2ModParams.nHomeVeloFast;
			nRecentHomeVeloSlow      := stMCS2ModParams.nHomeVeloSlow;
			nRecentHomeAcc   		 := stMCS2ModParams.nHomeAcc;
			nRecentHomeOffset        := stMCS2ModParams.nHomeOffset;
			nRecentReferencingOpt    := stMCS2ModParams.nReferencingOpt;
			nRecentLogicalScaleOffset:= stMCS2ModParams.nLogicalScaleOffset;
			bHomingParamsSet S= TRUE;
        END_IF
        fbSetHomeVeloFast.bExecute := FALSE;
        fbSetHomeVeloSlow.bExecute := FALSE;
        fbSetHomeAcc.bExecute     := FALSE;
        fbSetHomeOffs.bExecute    := FALSE;
        fbReferencingOptWrite.bExecute    := FALSE;
        fbLogicalScaleOffsetWrite.bExecute:= FALSE;
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetJogParams" Id="{4e8302eb-f6c2-4802-bf37-2e40ea9fd85c}">
      <Declaration><![CDATA[(*	MCS2 OL Step parameters update
    1- Step
    2- Step Amplitude
    3- StepFreq
*)
METHOD SetJogParams
VAR_INPUT
    Enable : BOOL;
END_VAR

VAR_INST
    // Open Loop Operations
    {attribute 'hide'}
    fbSetSteps			: FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbSetStepFreq 		: FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbSetStepAmp  		: FB_EcCoESdoWrite;
    {attribute 'hide'}
    nRecentSteps		: DINT;
    {attribute 'hide'}
    nRecentStepAmp		: UINT;
    {attribute 'hide'}
    nRecentStepFreq		: UINT;
    {attribute 'hide'}
    ftStepAmpUpdateDone	: F_TRIG;
    {attribute 'hide'}
    ftStepFreqUpdateDone	: F_TRIG;
    {attribute 'hide'}
    ftStepUpdateDone	: F_TRIG;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Enable THEN
  ScaleJogParams();
  
  fbSetSteps(
    sNetId     :=  stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr := stDS402Drive.nSlaveAddr,
    nIndex     := nChanStepIdx,
    nSubIndex  := 0,
    pSrcBuf    := ADR(nScalededSteps),
    cbBufLen   := SIZEOF(stMCS2ModParams.nChanStep),
    bExecute   := (nScalededSteps <> nRecentSteps)
  );
  fbSetStepAmp(
    sNetId     :=  stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr := stDS402Drive.nSlaveAddr,
    nIndex     := nChanStepAmpIdx,
    nSubIndex  := 0,
    pSrcBuf    := ADR(nScalededStepAmp),
    cbBufLen   := SIZEOF(stMCS2ModParams.nChanStepAmp),
    bExecute   := (nScalededStepAmp <> nRecentStepAmp)
  );
  fbSetStepFreq(
    sNetId     :=  stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr := stDS402Drive.nSlaveAddr,
    nIndex     := nChanStepFreqIdx,
    nSubIndex  := 0,
    pSrcBuf    := ADR(nScaledStepFreq),
    cbBufLen   := SIZEOF(stMCS2ModParams.nChanStepFreq),
    bExecute   := (nScaledStepFreq <> nRecentStepFreq)
  );
  ftStepUpdateDone(CLK:=fbSetSteps.bBusy);
  ftStepAmpUpdateDone(CLK:=fbSetStepAmp.bBusy);
  ftStepFreqUpdateDone(CLK:=fbSetStepFreq.bBusy);

    bStepModeParamsSet R= fbSetSteps.bBusy OR fbSetStepAmp.bBusy OR fbSetStepFreq.bBusy;
  IF ftStepUpdateDone.Q
        OR ftStepAmpUpdateDone.Q
        OR ftStepFreqUpdateDone.Q THEN
    IF fbSetSteps.bError THEN
             stMotionStage.bError := fbSetSteps.bError;
             stMotionStage.nErrorId := fbSetSteps.nErrId;
        ELSIF fbSetStepFreq.bError THEN
             stMotionStage.bError := fbSetStepFreq.bError;
             stMotionStage.nErrorId := fbSetStepFreq.nErrId;
        ELSIF fbSetStepAmp.bError THEN
             stMotionStage.bError := fbSetStepAmp.bError;
             stMotionStage.nErrorId := fbSetStepAmp.nErrId;
    ELSE
        nRecentSteps := nScalededSteps;
        nRecentStepAmp := nScalededStepAmp;
        nRecentStepFreq := nScaledStepFreq;
        bStepModeParamsSet S= TRUE;
    END_IF
        fbSetSteps.bExecute := FALSE;
        fbSetStepFreq.bExecute := FALSE;
        fbSetStepAmp.bExecute := FALSE;
    END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{08b990dd-982c-4d9b-9ed0-d47355966885}">
      <Declaration><![CDATA[METHOD StateMachine
VAR_INPUT
    Enable : BOOL;
END_VAR

VAR_INST
    rtFault: R_TRIG;
    {attribute 'hide'}
    bFault				: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*switch on disable*)
IF NOT stDS402Drive.stDS402DriveStatus.ReadyToSwitchOn
    AND NOT stDS402Drive.stDS402DriveStatus.SwitchedOn
    AND NOT stDS402Drive.stDS402DriveStatus.OperationEnabled
    AND NOT stDS402Drive.stDS402DriveStatus.Fault
    AND stDS402Drive.stDS402DriveStatus.VoltageEnabled
    AND NOT stDS402Drive.stDS402DriveStatus.QuickStopActive
    AND  stDS402Drive.stDS402DriveStatus.SwitchOnDisabled THEN
        bOperational := FALSE;
        bFault := FALSE;
        IF bManualTransition THEN
            THIS^.stDS402Drive.nDS402DriveControl := 6;
        END_IF
(*Ready to switch*)
ELSIF stDS402Drive.stDS402DriveStatus.ReadyToSwitchOn
    AND NOT stDS402Drive.stDS402DriveStatus.SwitchedOn
    AND NOT stDS402Drive.stDS402DriveStatus.OperationEnabled
    AND NOT stDS402Drive.stDS402DriveStatus.Fault
    AND stDS402Drive.stDS402DriveStatus.VoltageEnabled
    AND stDS402Drive.stDS402DriveStatus.QuickStopActive
    AND NOT stDS402Drive.stDS402DriveStatus.SwitchOnDisabled THEN
        bFault := FALSE;
        bOperational := FALSE;
        IF bManualTransition THEN
            THIS^.stDS402Drive.nDS402DriveControl := 7;
        END_IF
(*Switch on*)
ELSIF stDS402Drive.stDS402DriveStatus.ReadyToSwitchOn
    AND  stDS402Drive.stDS402DriveStatus.SwitchedOn
    AND NOT stDS402Drive.stDS402DriveStatus.OperationEnabled
    AND NOT stDS402Drive.stDS402DriveStatus.Fault
    AND stDS402Drive.stDS402DriveStatus.VoltageEnabled
    AND stDS402Drive.stDS402DriveStatus.QuickStopActive
    AND NOT stDS402Drive.stDS402DriveStatus.SwitchOnDisabled THEN
        bOperational := FALSE;
        IF bManualTransition THEN
            THIS^.stDS402Drive.nDS402DriveControl := 15;
        END_IF
(*Operation enbaled*)
ELSIF stDS402Drive.stDS402DriveStatus.ReadyToSwitchOn
    AND stDS402Drive.stDS402DriveStatus.SwitchedOn
    AND stDS402Drive.stDS402DriveStatus.OperationEnabled
    AND NOT stDS402Drive.stDS402DriveStatus.Fault
    AND stDS402Drive.stDS402DriveStatus.VoltageEnabled
    AND stDS402Drive.stDS402DriveStatus.QuickStopActive
    AND NOT stDS402Drive.stDS402DriveStatus.SwitchOnDisabled THEN
        THIS^.bOperational := TRUE;
(*Fault*)
ELSIF  NOT stDS402Drive.stDS402DriveStatus.ReadyToSwitchOn
    AND NOT stDS402Drive.stDS402DriveStatus.SwitchedOn
    AND NOT stDS402Drive.stDS402DriveStatus.OperationEnabled
    AND stDS402Drive.stDS402DriveStatus.Fault
    AND stDS402Drive.stDS402DriveStatus.VoltageEnabled
    AND NOT stDS402Drive.stDS402DriveStatus.QuickStopActive
    AND NOT stDS402Drive.stDS402DriveStatus.SwitchOnDisabled THEN
        bOperational := FALSE;
        bFault := TRUE;

ELSE
    bFault := FALSE;
    bOperational := FALSE;
END_IF

// wait for parameter init done at startup to read potential error from drive
 stMotionStage.bError := bFault AND  stMotionStage.bAxisParamsInit;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="StepMove" Id="{74869c9c-654c-4a5a-9a50-bfad55265981}">
      <Declaration><![CDATA[METHOD  StepMove
VAR_INPUT
    Enable : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[rtStepMove(CLK:=Enable);
CASE eMotionState OF
    E_MoveState.IDLING:;
        // Motion states
        IF rtStepMove.Q THEN
            // enter move discrete or continous here:
            bStepMoveBusy := TRUE;
            bStepMoveDone := FALSE;
            stMotionStage.bDone:=FALSE;
            bSteModeEnable := FALSE;
            stDS402Drive.nDS402DriveControl:=15;
            eMotionState:=E_MoveState.INIT;
        END_IF
    E_MoveState.INIT:
            IF stMotionStage.bError THEN
                eMotionState:=E_MoveState.ERROR;
            ELSE
                stDS402Drive.nDS402DriveControl:=31;
				eMotionState:=E_MoveState.IN_PROGRESS;
            END_IF

    E_MoveState.IN_PROGRESS:
        IF bStop THEN
            stDS402Drive.nDS402DriveControl.8 :=1;
            bStepMoveAborted := TRUE;
            eMotionState:=E_MoveState.INTERRUPTED;
        ELSIF stDS402Drive.stDS402DriveStatus.Bit13_OpModeSpecific THEN
            stMotionStage.bError := TRUE;
            eMotionState:=E_MoveState.ERROR;
        ELSE
            // Reached ?
            IF stDS402Drive.stDS402DriveStatus.TargetReached
                 AND NOT stDS402Drive.stDS402DriveStatus.Bit12_OpModeSpecific THEN
                eMotionState:=E_MoveState.REACHED;
            END_IF
        END_IF
    E_MoveState.INTERRUPTED:
        IF (stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION ) THEN
            bPositionHold := TRUE;
            tonHoldTime.IN:=TRUE;
        END_IF
		stDS402Drive.nDS402DriveControl:=15;
        bStepMoveBusy:=FALSE;
        eMotionState:=E_MoveState.IDLING;
    E_MoveState.REACHED:
        // Release the endstop override
        bLimOverride := FALSE;
        bStepMoveBusy:=FALSE;
        IF (stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION ) THEN
            bPositionHold := TRUE;
            tonHoldTime.IN:=TRUE;
        END_IF
        bStepMoveDone:=TRUE;
        stDS402Drive.nDS402DriveControl:=15;
        IF stMotionStage.bDone THEN
            eMotionState:=E_MoveState.IDLING;
        END_IF
    E_MoveState.ERROR:
        bStepMoveBusy:=FALSE;
        bStepMoveDone:=FALSE;
        IF bWrongParameter THEN
            stMotionStage.sCustomErrorMessage:='Invalid motion Parameters';
            bWrongParameter := FALSE;
            stMotionStage.bError := TRUE;
        END_IF
        IF NOT stMotionStage.bError THEN
            eMotionState:=E_MoveState.IDLING;
        END_IF
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="WriteParameterNC" Id="{a04e1bd8-55ae-495c-bca4-be27f11603b4}">
      <Declaration><![CDATA[METHOD WriteParameterNC
VAR_INPUT
    Execute:BOOL;
    ParameterNumber : MC_AxisParameter;
    ParameterValue	: LREAL;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*Do not change a moving axis parameter*)
fbMcWriteParameter(	Axis:=FB_MotionStageMCS2.stMotionStage.Axis,
                    Execute:=(Execute AND FB_MotionStageMCS2.stMotionStage.Axis.Status.NotMoving),
                    ParameterNumber:=ParameterNumber,
                    Value:=ParameterValue );
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>