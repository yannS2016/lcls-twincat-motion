<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_MotionStageMCS2" Id="{8a1beccb-8ae6-4cef-98b6-1d3261aefb9e}" SpecialFunc="None">
    <Declaration><![CDATA[(*
    MCS2 Motion Stage
    Controls a stage in CSP (NC), STEP_MODE, and Homing via DS402 interface.
    - Uses overridden Position Holding timer.
    - power enable mode must be 'DURING_MOTION' for closed-loop (CSP) control.
    - Set bServo PV to true for closed-loop, clear for open-loop (step mode).
*)

{attribute 'call_after_init'}
FUNCTION_BLOCK FB_MotionStageMCS2 IMPLEMENTS I_DS402GenericDrive

VAR
    {attribute 'no_copy'}
    stMotionStage            : REFERENCE TO ST_MCS2Stage;
    // Hardware I/O
    stDS402Drive             : ST_DS402Drive;
    {attribute 'hide'}
    eModule                  : E_Module;
    {attribute 'hide'}
    eHomeMode                : E_EpicsHomeCmd := E_EpicsHomeCmd.AUTOZERO;
    {attribute 'hide'}
    eBufferMode              : MC_BufferMode := MC_BufferMode.MC_Aborting;
    {attribute 'hide'}
    eStepState             : E_MoveState;
    {attribute 'hide'}
    eHomeState               : E_MoveState;
    {attribute 'hide'}
    eCalibrateState         : E_MoveState;

    {attribute 'hide'}
    fbMcPower             : MC_Power;
    {attribute 'hide'}
    fbMcMoveAbsolute      : MC_MoveAbsolute;
    {attribute 'hide'}
    fbMcHalt              : MC_Halt;
    {attribute 'hide'}
    fbMcReset             : MC_Reset;
    {attribute 'hide'}
    fbMcWriteParameter    : MC_WriteParameter;
    {attribute 'hide'}
    fbMcReadParams        : MC_ReadParameterSet;
    {attribute 'hide'}
    bLastHoltTimeOut      : BOOL;
    {attribute 'hide'}
    bEnPosLag             : BOOL;
    {attribute 'hide'}
    bWrongParameter       : BOOL;
    {attribute 'hide'}
    bExecMove             : BOOL;
    {attribute 'hide'}
    bExecHome             : BOOL;
    {attribute 'hide'}
    bNewMoveReq           : BOOL;
    {attribute 'hide'}
    bHomeBusy             : BOOL;
    {attribute 'hide'}
    bPrepareDisable       : BOOL;
    {attribute 'hide'}
    bStepMoveDone         : BOOL;
    {attribute 'hide'}
    bStepMoveBusy         : BOOL;
    {attribute 'hide'}
    bHalt                 : BOOL;
    {attribute 'hide'}
    bOperational          : BOOL;
    {attribute 'hide'}
    bLimOverride          : BOOL;
    {attribute 'hide'}
    bPositionHold         : BOOL;
    {attribute 'hide'}
    bLocalExec            : BOOL;
    {attribute 'hide'}
    bSystemInit           : BOOL;
    {attribute 'hide'}
    bHomeDone             : BOOL;
    {attribute 'hide'}
    bCalibrationModeEnabled : BOOL;
    {attribute 'hide'}
    bStepModeEnabled         : BOOL;
    {attribute 'hide'}
    bHomeModeEnabled         : BOOL;
    {attribute 'hide'}
    bCSPModeEnabled          : BOOL;
    {attribute 'hide'}
    bSteModeEnable           : BOOL;
    {attribute 'hide'}
    bRestoreLoad             : BOOL;
    {attribute 'hide'}
    bStepModeParamsSet   : BOOL;
    {attribute 'hide'}
    bCalibrationAborted : BOOL;
    {attribute 'hide'}
    bCalibrationDone : BOOL;
    {attribute 'hide'}
    bExecParamsRead          : BOOL;
    {attribute 'hide'}
    bCommandMoveAbsolute     : BOOL;
    {attribute 'hide'}
    bRecentEnPosLagStatus    : BOOL;
    {attribute 'hide'}
    bDS402ManualAborted      : BOOL;
    {attribute 'hide'}
    bStepMoveAborted         : BOOL;
    {attribute 'hide'}
    bHomeAborted             : BOOL;
    {attribute 'hide'}
    bDS402Manual      : BOOL;
    {attribute 'hide'}
    bReset              : BOOL;
    {attribute 'hide'}
    nCmdDataLocal            : INT;
    {attribute 'hide'}
    bManualTransition        : BOOL;
    // ====== Measurements & scaled values ======
    {attribute 'hide'}
    nScaledFErrWin      : DINT;
    {attribute 'hide'}
    nScalededSteps      : DINT;
    {attribute 'hide'}
    fScalededSteps           : LREAL;
    {attribute 'hide'}
    fMeasuredVelo            : LREAL;
    {attribute 'hide'}
    fMeasuredAcc             : LREAL;
    {attribute 'hide'}
    fParameterValue          : LREAL;
    {attribute 'hide'}
    fMeasuredPos             : LREAL;
    // ====== Internal numeric parameters ======
    {attribute 'hide'}
    nScalededStepAmp         : UINT;
    {attribute 'hide'}
    nScaledStepFreq          : UINT;
    // ====== Timer and trigger FBs ======
    {attribute 'hide'}
    tonInitTimer             : TON;
    {attribute 'hide'}
    tonSyncHoming            : TON;
    {attribute 'hide'}
    tonHoldTime              : TON;
    {attribute 'hide'}
    tonSlowParamReadTimer    : TON;
    {attribute 'hide'}
    NCParamsTimer            : TON;
    {attribute 'hide'}
    tonRestoreRetry          : TON;

    {attribute 'hide'}
    rtExec                   : R_TRIG;
    {attribute 'hide'}
    rtMoveCmdShortcut        : R_TRIG;
    {attribute 'hide'}
    rtHomeCmdShortcut        : R_TRIG;
    {attribute 'hide'}
    rtEnableMode             : R_TRIG;
    {attribute 'hide'}
    rtUserExec               : R_TRIG;
    {attribute 'hide'}
    rtModeChange             : R_TRIG;
    {attribute 'hide'}
    rtMoveDone               : R_TRIG;
    {attribute 'hide'}
    rtNewMoveReq             : R_TRIG;
    {attribute 'hide'}
    ftExec                   : F_TRIG;
    {attribute 'hide'}
    rtCSPModeOk              : R_TRIG;
    {attribute 'hide'}
    rtHomeModeEnable         : R_TRIG;
    {attribute 'hide'}
    rtStepModeEnabled        : R_TRIG;
    {attribute 'hide'}
    rtNewServoMove           : R_TRIG;
    {attribute 'hide'}
    rtStepMove               : R_TRIG;
    rtHaltEdge : R_TRIG; // Rising edge for bHalt
    {attribute 'hide'}
    eDoneCause : E_MoveDoneCause := E_MoveDoneCause.Unknown;
    // ====== Channel-specific object indices ======
    nSubIndex                : BYTE := 0;        // Main subindex (which channel)
    {attribute 'hide'}
    nChanFErrWinIdx          : WORD;
    {attribute 'hide'}
    nChanSoftwareLimIdx      : WORD;
    {attribute 'hide'}
    nChanMotorLoadIdx        : WORD;
    {attribute 'hide'}
    nChanErrorCodeIdx        : WORD;
    {attribute 'hide'}
    nChanStepIdx             : WORD;
    {attribute 'hide'}
    nChanStepFreqIdx         : WORD;
    {attribute 'hide'}
    nChanStepAmpIdx          : WORD;
    {attribute 'hide'}
    nChanSoftLimitIdx        : WORD;
    {attribute 'hide'}
    nChanHomeOffsIdx         : WORD;
    {attribute 'hide'}
    nChanHomeVeloIdx         : WORD;
    {attribute 'hide'}
    nChanhomeAccIdx          : WORD;
    {attribute 'hide'}
    nMaxCloseLoopFreqIdx     : WORD;
    {attribute 'hide'}
    nPositionerTypeIdx       : WORD;
    {attribute 'hide'}
    nCalibrationOptIdx       : WORD;
    {attribute 'hide'}
    nSensorPowerModeIdx      : WORD;
    {attribute 'hide'}
    nReferencingOptIdx       : WORD;
    {attribute 'hide'}
    nReferenceTypeIdx        : WORD;
    {attribute 'hide'}
    nSafeDirIdx              : WORD;
    {attribute 'hide'}
    nMotorLoadIdx            : WORD;
    {attribute 'hide'}
    nChannelTypeIdx          : WORD;
    {attribute 'hide'}
    nChannelStateIdx         : WORD;
    {attribute 'hide'}
    nLogicalScaleOffsetIdx   : WORD;
    {attribute 'hide'}
    nLogicalScaleInvIdx      : WORD;
    {attribute 'hide'}
    rtStepCmdShortcut: R_TRIG;
    {attribute 'hide'}
    rtCalibrateCmdShortcut: R_TRIG;
    {attribute 'hide'}
    bCommandMoveStep: BOOL;
    {attribute 'hide'}
    bCalibrationsParamsSet: BOOL := TRUE;
    {attribute 'hide'}
    bHomingParamsSet: BOOL;
    {attribute 'hide'}
    bCalibrateMoveAborted: BOOL;
    {attribute 'hide'}
    bCalibrateMoveDone: BOOL;
    {attribute 'hide'}
    bChanParamsSet: BOOL;
    {attribute 'hide'}
    bCalibrationBusy: BOOL;
END_VAR

VAR CONSTANT
    {attribute 'hide'}
    nChanSoftLimitBase       : WORD := 16#200E;
    {attribute 'hide'}
    nHomeOffsetBase          : WORD := 16#607C;
    {attribute 'hide'}
    nHomingSpeedBase         : WORD := 16#6099;
    {attribute 'hide'}
    nhomingAccBase           : WORD := 16#609A;
    {attribute 'hide'}
    nErrorCodeBase           : WORD := 16#603F;
    {attribute 'hide'}
    nFErrWinBase             : WORD := 16#6065;
    {attribute 'hide'}
    nChanOfsBase             : WORD := 16#800;      // For SmartAct MCS2 and E-727
    {attribute 'hide'}
    nEncErrorCode            : WORD := 16#7300;     // Motor encoder defective code (for save/restore)
    {attribute 'hide'}
    nSoftLimBase             : WORD := 16#200E;
    {attribute 'hide'}
    nOlStepBase              : WORD := 16#2022;
    {attribute 'hide'}
    nOlStepAmpBase           : WORD := 16#2023;
    {attribute 'hide'}
    nOlStepFreqBase          : WORD := 16#2024;
    {attribute 'hide'}
    nMaxCloseLoopFreqBase    : WORD := 16#2001;
    {attribute 'hide'}
    nPositionerTypeBase      : WORD := 16#2000;
    {attribute 'hide'}
    nCalibrationOptBase      : WORD := 16#2004;
    {attribute 'hide'}
    nSensorPowerModeBase     : WORD := 16#2007;
    {attribute 'hide'}
    nReferencingOptBase      : WORD := 16#200B;
    {attribute 'hide'}
    nReferenceTypeBase       : WORD := 16#200A;
    {attribute 'hide'}
    nSafeDirBase             : WORD := 16#200C;
    {attribute 'hide'}
    nMotorLoadBase           : WORD := 16#200D;
    {attribute 'hide'}
    nChannelTypeBase         : WORD := 16#200F;
    {attribute 'hide'}
    nChannelStateBase        : WORD := 16#2025;
    {attribute 'hide'}
    nLogicalScaleOffsetBase  : WORD := 16#2008;
    {attribute 'hide'}
    nLogicalScaleInvBase     : WORD := 16#2009;
END_VAR

VAR PERSISTENT
    nCommandLocal            : INT;
    bSaved                   : BOOL;
    fSavedPosition           : LREAL;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF NOT __ISVALIDREF( stMotionStage) THEN
    RETURN;
END_IF

// when the plc autoboot it appears reading from i/o is not yet after 'call_after_init'
IF bSystemInit THEN
    IF  stMotionStage.Axis.NcToPlc.AxisId <> 0 THEN
        stDS402Drive.nDS402DriveControl := 128; // clear errors, prepare for startup
        bExecParamsRead := TRUE; // trigger NC param read on first scan
        bSystemInit := FALSE;
    END_IF
END_IF
(* Check for the plc shortcut commands
   Used for testing or to circumvent motor record issues*)
rtMoveCmdShortcut(CLK:= stMotionStage.bMoveCmd);
rtHomeCmdShortcut(CLK:= stMotionStage.bHomeCmd);
rtStepCmdShortcut(CLK:= stMotionStage.stMCS2ChanParams.bStepMoveCmd);
rtCalibrateCmdShortcut(CLK:= stMotionStage.stMCS2ChanParams.bCalibrationCmd);

(* Execute on rising edge*)
IF rtMoveCmdShortcut.Q AND NOT stMotionStage.bExecute THEN
    stMotionStage.bExecute := TRUE;
    stMotionStage.nCommand := E_EpicsMotorCmd.MOVE_ABSOLUTE;
    bEnPosLag := bRecentEnPosLagStatus;
    fParameterValue := BOOL_TO_LREAL(bRecentEnPosLagStatus);

ELSIF rtStepCmdShortcut.Q AND NOT stMotionStage.bExecute THEN
    stMotionStage.bExecute := TRUE;
    stMotionStage.nCommand := E_EpicsMotorCmd.JOG;           // Step mode uses JOG
    nCommandLocal := E_EpicsMotorCmd.JOG;
    bEnPosLag := bRecentEnPosLagStatus;
    fParameterValue := BOOL_TO_LREAL(bRecentEnPosLagStatus);

ELSIF rtCalibrateCmdShortcut.Q AND NOT stMotionStage.bExecute THEN
    stMotionStage.bExecute := TRUE;
    stMotionStage.nCommand := E_EpicsMotorCmd.CALIBRATE;     // Calibration mode uses CALIBRATE
    nCommandLocal := E_EpicsMotorCmd.CALIBRATE;
    bEnPosLag := bRecentEnPosLagStatus;
    fParameterValue := BOOL_TO_LREAL(bRecentEnPosLagStatus);

ELSIF rtHomeCmdShortcut.Q AND NOT stMotionStage.bExecute THEN
    stMotionStage.bExecute := NOT (stMotionStage.nCmdData = E_EpicsHomeCmd.ABSOLUTE_SET)
                             OR NOT (stMotionStage.nCmdData = E_EpicsHomeCmd.NONE);
    stMotionStage.nCommand := E_EpicsMotorCmd.HOME;
    stMotionStage.nCmdData := stMotionStage.nHomingMode;
    IF stMotionStage.stAxisParameters.bCtrlEnablePosDiffControl.0 THEN
        bRecentEnPosLagStatus := stMotionStage.stAxisParameters.bCtrlEnablePosDiffControl.0;
        bEnPosLag := TRUE;
        fParameterValue := 0;
    END_IF
END_IF

(* entry point for local and EPICS main execs *)
rtUserExec(CLK:= stMotionStage.bExecute);
(* if a Move/Home Goal is comfirmed and there is no persistant
   error conditions, then we have a valid move request.*)
bNewMoveReq S= NOT  stMotionStage.bBusy AND rtUserExec.Q AND NOT  stMotionStage.bError;
(* this Move request is valid till an error occurs or the currently move is done *)
bNewMoveReq R= NOT  stMotionStage.bExecute OR  stMotionStage.bError;
bPrepareDisable R= bNewMoveReq;
rtNewMoveReq(CLK:=bNewMoveReq);
(* Moves are automatically allowed if no safety hooks.
   Otherwise, some other code will set this.*)
 stMotionStage.bSafetyReady :=  stMotionStage.bPowerSelf;
(* Set the proper command for the request move;
   if bservo not set, manual step moves will be performed *)
IF rtUserExec.Q THEN
    //  if we enter here form state movers
    stMotionStage.bMoveCmd := TRUE;
    nCommandLocal := E_EpicsMotorCmd.MOVE_ABSOLUTE;
    IF stMotionStage.bHomeCmd THEN
        nCommandLocal := stMotionStage.nCommand;
        nCmdDataLocal := stMotionStage.nCmdData;
    ELSIF stMotionStage.stMCS2ChanParams.bStepMoveCmd THEN
        // For stepmode, directly write the command
        stMotionStage.nCommand := E_EpicsMotorCmd.JOG;
        nCommandLocal := E_EpicsMotorCmd.JOG;
    ELSIF stMotionStage.stMCS2ChanParams.bCalibrationCmd THEN
        // For calibration, directly write the command
        stMotionStage.nCommand := E_EpicsMotorCmd.CALIBRATE;
        nCommandLocal := E_EpicsMotorCmd.CALIBRATE;
    END_IF

    IF NOT stMotionStage.bHomeCmd AND NOT stMotionStage.stMCS2ChanParams.stChannelState.bIsReferenced THEN
        // attempting to move an axis without homing first?
        IF stMotionStage.nHomingMode <> E_EpicsHomeCmd.NONE AND NOT stMotionStage.bHomed THEN
            stMotionStage.sErrorMessage := 'Axis homing mode set, but homing routine pending';
        END_IF
    END_IF
END_IF

(* Set the drive in the correct operating mode. based on requested move command!
    NB: bservo must set for close loop motion
*)
ModeOperation();

(* NB: This is the only tested mode of operation so far. also aligned
    piezo drive position holding feature
*)
rtEnableMode(CLK:=( stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION));
(* Handle auto-enable timing *)
CASE  stMotionStage.nEnableMode OF
    (* Not recommended, not tested *)
    E_StageEnableMode.ALWAYS:
         stMotionStage.bEnable:=stMotionStage.bSafetyReady;
    E_StageEnableMode.DURING_MOTION:
        IF rtEnableMode.Q THEN
             stMotionStage.bEnable := FALSE;
        END_IF
        IF rtNewMoveReq.Q THEN
            (* override ongoing holding.*)
            bPositionHold := FALSE;
            tonHoldTime.IN:=FALSE;
            (*MC block are not compatible with open loop Motion
                thus we wathc for correct close loop modes to use NC features *)
             stMotionStage.bEnable :=  stMotionStage.bSafetyReady;
            bLastHoltTimeOut := FALSE;
            bHalt:=FALSE;
        END_IF
END_CASE
(*  Interlock mainly react on internal limit conditions inthe ove direction.
    MCS2 drive will go into error state when an internal limit is hit *)
Interlock();

IF bCSPModeEnabled THEN
    bLocalExec := NOT stMotionStage.bError
                  AND stMotionStage.bExecute
                  AND stMotionStage.bAllEnable
                  AND stMotionStage.bEnableDone
                  AND stMotionStage.bSafetyReady
                  AND nCommandLocal = E_EpicsMotorCmd.MOVE_ABSOLUTE;
ELSIF bHomeModeEnabled THEN
    bLocalExec := NOT stMotionStage.bError
                  AND stMotionStage.bExecute
                  AND stMotionStage.bAllEnable
                  AND bOperational
                  AND stMotionStage.bSafetyReady
                  AND nCommandLocal = E_EpicsMotorCmd.HOME;
ELSIF bStepModeEnabled THEN
    bLocalExec := NOT stMotionStage.bError
                  AND stMotionStage.bExecute
                  AND stMotionStage.bAllEnable
                  AND bOperational
                  AND stMotionStage.bSafetyReady
                  AND nCommandLocal = E_EpicsMotorCmd.JOG;
ELSIF bCalibrationModeEnabled THEN
    bLocalExec := NOT stMotionStage.bError
                  AND stMotionStage.bExecute
                  AND stMotionStage.bAllEnable
                  AND bOperational
                  AND stMotionStage.bSafetyReady
                  AND nCommandLocal = E_EpicsMotorCmd.CALIBRATE;
ELSE
    bLocalExec := FALSE;
END_IF

bExecMove:=bLocalExec AND ((nCommandLocal=E_EpicsMotorCmd.MOVE_ABSOLUTE)
                      OR (nCommandLocal=E_EpicsMotorCmd.JOG)
                      OR (nCommandLocal=E_EpicsMotorCmd.CALIBRATE));
bExecHome:=bLocalExec AND NOT bExecMove;

(* When we start, set the busy/done appropriately
   NB: CLose loop control using NC *)
rtExec(CLK:=bLocalExec);
IF rtExec.Q THEN
    // Release previous interruption if any
    stDS402Drive.nDS402DriveControl.8 := FALSE;
    stMotionStage.bDone := FALSE;
END_IF

(* updated axis status
   Not needed in manual mode *)
IF NOT bDS402Manual THEN
     stMotionStage.Axis.ReadStatus();
END_IF

(* Get a definitive bEnabled reading
   NB: use only in close loop mode, NC feature needed*)
CASE  stMotionStage.Axis.Status.MotionState OF
    (* We are not enabled if there is an issue*)
    MC_AXISSTATE_UNDEFINED, MC_AXISSTATE_DISABLED, MC_AXISSTATE_ERRORSTOP:
         stMotionStage.bEnableDone := FALSE;
    ELSE
         stMotionStage.bEnableDone := TRUE;
END_CASE
//
IF stMotionStage.bReset THEN
    // Clear all motion and error flags
    stMotionStage.bExecute := FALSE;
    stMotionStage.bError := FALSE;
    stMotionStage.nErrorId := 0;
    stMotionStage.sErrorMessage := '';
    stMotionStage.sCustomErrorMessage := '';
    //IF stMotionStage.bBusy THEN
        bReset := TRUE;
    //END_IF

    IF bDS402Manual THEN
        // Set bit 7 for reset in manual mode
        stDS402Drive.nDS402DriveControl.7 := TRUE;
        bManualTransition := FALSE;
    END_IF
    stMotionStage.bReset := FALSE;
END_IF
// EPICS user requested a stop ?
ftExec(CLK := stMotionStage.bExecute);

// Halt is always a user stop during motion
// bHalt S= ftExec.Q AND NOT bReset
//      AND ((bHomeBusy AND (nCommandLocal = E_EpicsMotorCmd.HOME))
//       OR (fbMcMoveAbsolute.Busy AND (nCommandLocal = E_EpicsMotorCmd.MOVE_ABSOLUTE))
//       OR (bStepMoveBusy  AND (nCommandLocal = E_EpicsMotorCmd.JOG))
//       OR (bCalibrationBusy  AND (nCommandLocal = E_EpicsMotorCmd.CALIBRATE))
//      );
bHalt:=ftExec.Q AND stMotionStage.bBusy;
rtHaltEdge(CLK := bHalt);
IF rtHaltEdge.Q AND bDS402Manual THEN
    stDS402Drive.nDS402DriveControl.8 := TRUE;
END_IF

//auto handle position lag monitoring, disable during homing.
WriteParameterNC(   Execute:=bEnPosLag,
                    ParameterNumber:=MC_AxisParameter.AxisEnPositionLagMonitoring,
                    ParameterValue:=fParameterValue);

(* Requested commands processing *)
CASE nCommandLocal OF
    E_EpicsMotorCmd.MOVE_ABSOLUTE:
        (*NC CSP Move Handling*)
        Reset();
        Power();
        Halt();
        (*Wait for drive to be in the correct mode after a request was validated *)
        bCommandMoveAbsolute := bExecMove AND fbMcPower.Status AND bCSPModeEnabled;
        MoveAbsolute();
        (*IN CSP mode the drive control word is update via the NC
          Manual step mode and Homing will override this *)
        stDS402Drive.nDS402DriveControl := stDS402Drive.nDS402DriveControlNC;
    E_EpicsMotorCmd.HOME:
        (*DS402 Manual Homing*)
        Home(Enable:= bExecHome AND bChanParamsSet AND bHomingParamsSet AND NOT bWrongParameter );
    E_EpicsMotorCmd.JOG:
        (* Set drive to correct operating mode, ensure motion params are correct
          following a validated open loop mode request.
          NB: bservo must be off. a PV is provided for that
        *)
        StepMove(Enable := bExecMove AND bStepModeParamsSet AND NOT bWrongParameter);
    E_EpicsMotorCmd.CALIBRATE:
        Calibrate(Enable := bExecMove AND bChanParamsSet AND bCalibrationsParamsSet AND NOT bWrongParameter);
END_CASE

stMotionStage.bBusy := fbMcMoveAbsolute.Busy OR stMotionStage.stMCS2ChanParams.stChannelState.bReferencing OR bStepMoveBusy OR stMotionStage.stMCS2ChanParams.stChannelState.bCalibrating;

(* Check done moving via user stop, limit hit, Target Position reached, or from homing.*)
MotionEndPowerDisable();

(* update encoder value and calibrated position*)
ScaleEncRawValue();

(*Drive parameters*)
ExposedParameters(Enable:=TRUE, tRefreshDelay:=T#2S);

(*Sync NC setting to drive settings*)
SetChanParams(
    Enable:= stMotionStage.bAxisParamsInit
        AND NOT  stMotionStage.bBusy
);

SetCalibrationParams(
    Enable:=stMotionStage.bAxisParamsInit
        AND NOT  stMotionStage.bBusy AND bCalibrationModeEnabled
);

SetHomingParams(
    Enable:=stMotionStage.bAxisParamsInit AND NOT  stMotionStage.bBusy AND bHomeModeEnabled
 );

(* Open Loop Motion paramters Update*)
SetJogParams(
    Enable:= stMotionStage.bAxisParamsInit AND NOT  stMotionStage.bBusy AND bStepModeEnabled
);

(*Read MCS2 Channel Parameters*)
ReadChanParams();
(* Save and restore as long as not an absolute encoder*)
PersistParameters( Enable:= stMotionStage.nHomingMode <> E_EpicsHomeCmd.NONE);
(*Restore encoder value at initialization*)
RestoreMotionParams(Enable:= stMotionStage.nHomingMode <> E_EpicsHomeCmd.NONE);

(*EPICS Motor record Update*)
SetEpicsStatus();
(*
    Error from functions and Nc. The error will send to EPICS interface based on predifined
    priority: axis, power, backlash, absoluteMove, etc...
*)
IF fbMcPower.Error AND fbMcPower.Active THEN
     stMotionStage.bError:=fbMcPower.Error;
     stMotionStage.nErrorId:=fbMcPower.ErrorID;
ELSIF fbMcMoveAbsolute.Error THEN
     stMotionStage.bError:=fbMcMoveAbsolute.Error;
     stMotionStage.nErrorId:=fbMcMoveAbsolute.ErrorID;
ELSIF fbMcHalt.Error AND fbMcHalt.Active THEN
     stMotionStage.bError:=fbMcHalt.Error;
     stMotionStage.nErrorId:=fbMcHalt.ErrorID;
ELSIF fbMcReset.Error  THEN
     stMotionStage.bError:=fbMcReset.Error;
     stMotionStage.nErrorId:=fbMcReset.ErrorID;
ELSIF fbMcWriteParameter.Error THEN
     stMotionStage.bError:=fbMcWriteParameter.Error;
     stMotionStage.nErrorId:=fbMcWriteParameter.ErrorID;
ELSIF fbMcReadParams.Error AND NOT  stMotionStage.bBusy THEN
     stMotionStage.bError:=fbMcReadParams.Error;
     stMotionStage.nErrorId:=fbMcReadParams.ErrorID;
ELSE
    IF  stMotionStage.bBusy THEN
         stMotionStage.sErrorMessage := '';
         stMotionStage.sCustomErrorMessage := '';
    END_IF
END_IF;

(*Double function, prioritize NC error otherwise read drive channel error code*)
ReadDriveCodes();

IF  stMotionStage.sCustomErrorMessage <> ''
    AND  stMotionStage.sErrorMessage = '' THEN
     stMotionStage.sErrorMessage :=  stMotionStage.sCustomErrorMessage;
END_IF

(*Clear motion flag when error occurs*)
IF  stMotionStage.bError  THEN
    stMotionStage.bExecute := FALSE;
    stMotionStage.bBusy := FALSE;
    stMotionStage.bDone := FALSE;
    stMotionStage.bEnable := FALSE;
END_IF

(* We've got the rising edge clear this flags.*)
stMotionStage.bMoveCmd := FALSE;
stMotionStage.bHomeCmd := FALSE;
stMotionStage.stMCS2ChanParams.bStepMoveCmd := FALSE;
stMotionStage.stMCS2ChanParams.bCalibrationCmd := FALSE;
]]></ST>
    </Implementation>
    <Method Name="Calibrate" Id="{366a3de7-f782-4695-9a8f-c19bec667315}">
      <Declaration><![CDATA[METHOD PRIVATE Calibrate
VAR_INPUT
    Enable : BOOL;
END_VAR
VAR_INST
    rtCalibrateMove: R_TRIG;
    bCalibrateMoveBusy: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[rtCalibrateMove(CLK := Enable);

CASE eCalibrateState OF

    E_MoveState.IDLING:
        IF rtCalibrateMove.Q THEN
            bCalibrateMoveBusy := TRUE;
            bCalibrateMoveDone := FALSE;
            // Set bits 0-3 for calibration enable
            stDS402Drive.nDS402DriveControl.3 := TRUE;
            eCalibrateState := E_MoveState.INIT;
        END_IF

    E_MoveState.INIT:
        IF stMotionStage.bError THEN
            eCalibrateState := E_MoveState.ERROR;
        ELSIF stDS402Drive.stDS402DriveStatus.Bit12_OpModeSpecific THEN
            eCalibrateState := E_MoveState.REACHED;
        ELSE
            stDS402Drive.nDS402DriveControl.4 := TRUE;
            eCalibrateState := E_MoveState.IN_PROGRESS;
        END_IF

    E_MoveState.IN_PROGRESS:
        IF bHalt THEN
            bCalibrateMoveAborted := TRUE;
            eCalibrateState := E_MoveState.INTERRUPTED;
        ELSIF stDS402Drive.stDS402DriveStatus.Bit13_OpModeSpecific THEN
            stMotionStage.bError := TRUE;
            eCalibrateState := E_MoveState.ERROR;
        ELSE
            IF stDS402Drive.stDS402DriveStatus.TargetReached
              AND stDS402Drive.stDS402DriveStatus.Bit12_OpModeSpecific THEN
                eCalibrateState := E_MoveState.REACHED;
            END_IF
        END_IF

    E_MoveState.INTERRUPTED:
        IF (stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION) THEN
            bPositionHold := TRUE;
            tonHoldTime.IN := TRUE;
        END_IF
        stDS402Drive.nDS402DriveControl.4 := FALSE;
        bCalibrateMoveBusy := FALSE;
        eCalibrateState := E_MoveState.IDLING;

    E_MoveState.REACHED:
        bLimOverride := FALSE;
        bCalibrateMoveBusy := FALSE;
        IF (stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION) THEN
            bPositionHold := TRUE;
            tonHoldTime.IN := TRUE;
        END_IF
        bCalibrateMoveDone := TRUE;
        stDS402Drive.nDS402DriveControl.4 := FALSE;
        eCalibrateState := E_MoveState.DONE;
    E_MoveState.DONE:
        IF stMotionStage.bDone THEN
            eCalibrateState := E_MoveState.IDLING;
        END_IF
    E_MoveState.ERROR:
        bCalibrateMoveBusy := FALSE;
        IF bWrongParameter THEN
            stMotionStage.sCustomErrorMessage := 'Invalid motion Parameters';
            bWrongParameter := FALSE;
            stMotionStage.bError := TRUE;
        END_IF
        IF NOT stMotionStage.bError THEN
            eCalibrateState := E_MoveState.IDLING;
        END_IF

END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="ExposedParameters" Id="{bfdcb735-2f35-43ca-9b4a-eca418143c19}">
      <Declaration><![CDATA[METHOD PUBLIC  ExposedParameters
VAR_INPUT
    Enable : BOOL;
    tRefreshDelay: TIME;
END_VAR

VAR_INST
    {attribute 'hide'}
    bParamReadTimer     : BOOL := TRUE;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Periodic update of NC parameters
NCParamsTimer( IN:=Enable AND NOT bExecParamsRead, PT:=tRefreshDelay);
bExecParamsRead S= NCParamsTimer.Q;
fbMcReadParams(
    Parameter:= stMotionStage.stAxisParameters,
    Axis:= stMotionStage.Axis,
    Execute:= bExecParamsRead );

// Copy axis parameters that we want to expose to the EPICS layer.
 stMotionStage.stAxisParametersExposed.bCtrlEnablePosDiffControl     :=  stMotionStage.stAxisParameters.bCtrlEnablePosDiffControl;
 stMotionStage.stAxisParametersExposed.bEncEnableSoftEndMaxControl   :=  stMotionStage.stAxisParameters.bEncEnableSoftEndMaxControl;
 stMotionStage.stAxisParametersExposed.bEncEnableSoftEndMinControl   :=  stMotionStage.stAxisParameters.bEncEnableSoftEndMinControl;
 stMotionStage.stAxisParametersExposed.fAccelerationMax              :=  stMotionStage.stAxisParameters.fAccelerationMax;
 stMotionStage.stAxisParametersExposed.fCtrlPosDiffMax               :=  stMotionStage.stAxisParameters.fCtrlPosDiffMax;
 stMotionStage.stAxisParametersExposed.fCtrlPosDiffMaxTime           :=  stMotionStage.stAxisParameters.fCtrlPosDiffMaxTime;
 stMotionStage.stAxisParametersExposed.fDecelerationMax              :=  stMotionStage.stAxisParameters.fDecelerationMax;
 stMotionStage.stAxisParametersExposed.fEncSoftEndMax                :=  stMotionStage.stAxisParameters.fEncSoftEndMax;
 stMotionStage.stAxisParametersExposed.fEncSoftEndMin                :=  stMotionStage.stAxisParameters.fEncSoftEndMin;
 stMotionStage.stAxisParametersExposed.fVeloMaximum                  :=  stMotionStage.stAxisParameters.fVeloMaximum;
 stMotionStage.stAxisParametersExposed.fEncOffset                       :=  stMotionStage.stAxisParameters.fEncOffset;
 stMotionStage.stAxisParametersExposed.fEncScaleFactorInternal       :=  stMotionStage.stAxisParameters.fEncScaleFactorInternal;

bExecParamsRead R= fbMcReadParams.Done OR fbMcReadParams.Error;
 stMotionStage.bAxisParamsInit S= fbMcReadParams.Done;]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_Init" Id="{a8134580-303c-4b2f-8942-be52670189d3}">
      <Declaration><![CDATA[//FB_Init is always available implicitly and it is used primarily for initialization.
//The return value is not evaluated. For a specific influence, you can also declare the
//methods explicitly and provide additional code there with the standard initialization
//code. You can evaluate the return value.
METHOD FB_Init: BOOL
VAR_INPUT
    bInitRetains: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInCopyCode: BOOL;  // TRUE: the instance will be copied to the copy code afterward (online change)
    stMotionStage       :   REFERENCE TO ST_MCS2Stage;
    (*Mandatory must be unique for each MCS2 axis *)
    eModule : E_Module;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.stMotionStage REF= stMotionStage;
THIS^.eModule := eModule;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Halt" Id="{6287ad75-ad53-4d78-9e75-75537e8950c5}">
      <Declaration><![CDATA[METHOD Halt : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMcHalt(
    Axis :=  stMotionStage.Axis,
    Execute := bHalt,
    Deceleration :=  stMotionStage.fDeceleration,
    BufferMode := eBufferMode,
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Home" Id="{30e09e6f-3e19-461e-88df-b1cd53b15969}">
      <Declaration><![CDATA[METHOD PUBLIC Home
VAR_INPUT
    Enable              : BOOL;
END_VAR
VAR_INST
    rtHomeMove: R_TRIG;
    fbSetPos: MC_SetPosition;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[rtHomeMove(CLK := Enable);

CASE eHomeState OF

    E_MoveState.IDLING:
        IF rtHomeMove.Q THEN
            bHomeBusy := TRUE;
            stMotionStage.bDone := FALSE;
            fbSetPos.Options.ClearPositionLag := TRUE;
            stDS402Drive.nDS402DriveControl.3 := TRUE;
            eHomeState := E_MoveState.INIT;
        END_IF

    E_MoveState.INIT:
        IF stMotionStage.bError THEN
            eHomeState := E_MoveState.ERROR;
        ELSIF stDS402Drive.stDS402DriveStatus.Bit12_OpModeSpecific THEN // Already referenced
            eHomeState := E_MoveState.DONE;
        ELSE
            stDS402Drive.nDS402DriveControl.4 := TRUE;
            eHomeState := E_MoveState.STARTED;
        END_IF

    E_MoveState.STARTED:
        IF NOT stDS402Drive.stDS402DriveStatus.TargetReached
           AND NOT stDS402Drive.stDS402DriveStatus.Bit13_OpModeSpecific THEN
            eHomeState := E_MoveState.IN_PROGRESS;
        END_IF

    E_MoveState.IN_PROGRESS:
        IF bHalt THEN
            bHomeAborted := TRUE;
            eHomeState := E_MoveState.INTERRUPTED;
        ELSIF stDS402Drive.stDS402DriveStatus.Bit13_OpModeSpecific
           OR stDS402Drive.stDS402DriveStatus.WarningCondition THEN
            stMotionStage.bError := TRUE;
            eHomeState := E_MoveState.ERROR;
        ELSIF stDS402Drive.stDS402DriveStatus.TargetReached
           AND stDS402Drive.stDS402DriveStatus.Bit12_OpModeSpecific
           AND NOT stDS402Drive.stDS402DriveStatus.Bit13_OpModeSpecific THEN
            eHomeState := E_MoveState.DONE;
        END_IF

    E_MoveState.INTERRUPTED:
        IF stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION THEN
            bPositionHold := TRUE;
            tonHoldTime.IN := TRUE;
        END_IF
        stDS402Drive.nDS402DriveControl.4 := FALSE;
        bHomeBusy := FALSE;
        eHomeState := E_MoveState.IDLING;

    E_MoveState.DONE:
        bLimOverride := FALSE;
        IF stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION THEN
            bPositionHold := TRUE;
            tonHoldTime.IN := TRUE;
        END_IF
        bHomeBusy := FALSE;
        tonSyncHoming.IN := FALSE;
        bHomeDone := TRUE;
        stMotionStage.fPosition := 0.0;
        fbSetPos(
            Axis := stMotionStage.Axis,
            Execute := TRUE,
            Position := stMotionStage.fHomePosition
        );
        stDS402Drive.nDS402DriveControl.4 := FALSE;
        eHomeState := E_MoveState.IDLING;

    E_MoveState.ERROR:
        bHomeDone := FALSE;
        bHomeBusy := FALSE;
        IF bWrongParameter THEN
            stMotionStage.sCustomErrorMessage := 'Invalid motion Parameters';
            bWrongParameter := FALSE;
            stMotionStage.bError := TRUE;
        END_IF
        IF NOT stMotionStage.bError THEN
            eHomeState := E_MoveState.IDLING;
        END_IF

END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="Interlock" Id="{b0516fc0-3ac5-4a37-a4b7-b21194f9b805}">
      <Declaration><![CDATA[METHOD PUBLIC Interlock

VAR_INST
    {attribute 'hide'}
    bPositiveDirection  : BOOL;
    {attribute 'hide'}
    bNegativeDirection  : BOOL;
    {attribute 'hide'}
    ftForwardEnabled    : F_TRIG;

    {attribute 'hide'}
    ftBackwardEnabled   : F_TRIG;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Positive or Negative direction
bPositiveDirection:= stMotionStage.bBusy AND  stMotionStage.fPosDiff > 0;
bNegativeDirection:= stMotionStage.bBusy AND  stMotionStage.fPosDiff < 0;

// For SmartAct MCS2 these limit are range and enstop limits. however a single bit in the status is used
// bLimOverride  : act as an override after limit was hit to allow reverse movement
 stMotionStage.bLimitForwardEnable :=  bLimOverride OR NOT( bPositiveDirection AND stDS402Drive.stDS402DriveStatus.InternalLimitActive );
 stMotionStage.bLimitBackwardEnable := bLimOverride OR NOT( bNegativeDirection AND stDS402Drive.stDS402DriveStatus.InternalLimitActive );

// use falling trigger to avoid spaming  sErrorMessage
ftForwardEnabled(CLK:= stMotionStage.bLimitForwardEnable);
ftBackwardEnabled(CLK:= stMotionStage.bLimitBackwardEnable);

IF  NOT bHomeBusy AND ftForwardEnabled.Q THEN
    // Not an error, just a warning
     stMotionStage.sCustomErrorMessage:='Cannot move past positive limit.';
    IF NOT bStepModeEnabled THEN
        bLimOverride := TRUE;
        bHalt := TRUE;
    END_IF
END_IF

IF NOT bHomeBusy AND ftBackwardEnabled.Q THEN
    // Not an error, just a warning
     stMotionStage.sCustomErrorMessage:='Cannot move past Negative limit.';
    IF NOT bStepModeEnabled THEN
        bLimOverride := TRUE;
        bHalt := TRUE;
    END_IF
END_IF

IF NOT  stMotionStage.bError AND  stMotionStage.bExecute AND NOT  stMotionStage.bUserEnable THEN
     stMotionStage.bError := TRUE;
     stMotionStage.nErrorId := 1;
     stMotionStage.sCustomErrorMessage := 'Move requested, but user enable is disabled!';
END_IF

// Update all enable booleans
SetEnables();]]></ST>
      </Implementation>
    </Method>
    <Method Name="ModeOperation" Id="{101f52ed-fac5-4fd9-b68c-696a0d98bf98}">
      <Declaration><![CDATA[(*Switch the drive mod eof Operation
  Servo On: Profil Positioning or HOME
  Servo Off : STEP mode
*)
METHOD ModeOperation
VAR_INST
    rtCalibrationModeEnable : R_TRIG;      // Rising edge detection for calibration mode
    eRequestedManualMode: E_DS402OpMode;
    bPendingManualModeSwitch: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// === Mode enable flags (set only if operational and in correct mode) ===
IF bOperational THEN
    CASE stDS402Drive.nModeOfOperationDisplay OF
        E_DS402OpMode.CSP:
            bCSPModeEnabled := TRUE;
            bHomeModeEnabled := FALSE;
            bStepModeEnabled := FALSE;
            bCalibrationModeEnabled := FALSE;
        E_DS402OpMode.HOME:
            bCSPModeEnabled := FALSE;
            bHomeModeEnabled := TRUE;
            bStepModeEnabled := FALSE;
            bCalibrationModeEnabled := FALSE;
        E_DS402OpMode.MCS2_OL_STEP_MODE:
            bCSPModeEnabled := FALSE;
            bHomeModeEnabled := FALSE;
            bStepModeEnabled := TRUE;
            bCalibrationModeEnabled := FALSE;
        E_DS402OpMode.MCS2_CALIBRATION:
            bCSPModeEnabled := FALSE;
            bHomeModeEnabled := FALSE;
            bStepModeEnabled := FALSE;
            bCalibrationModeEnabled := TRUE;
        ELSE
            bCSPModeEnabled := FALSE;
            bHomeModeEnabled := FALSE;
            bStepModeEnabled := FALSE;
            bCalibrationModeEnabled := FALSE;
    END_CASE
ELSE
    bCSPModeEnabled := FALSE;
    bHomeModeEnabled := FALSE;
    bStepModeEnabled := FALSE;
    bCalibrationModeEnabled := FALSE;
END_IF

// === Evaluate and process manual/CSP mode switch/request ===
IF rtUserExec.Q AND (
       stMotionStage.stMCS2ChanParams.bStepMoveCmd
    OR stMotionStage.bHomeCmd
    OR stMotionStage.stMCS2ChanParams.bCalibrationCmd
    OR stMotionStage.bMoveCmd ) THEN

    // Which mode is requested?
    IF stMotionStage.stMCS2ChanParams.bStepMoveCmd THEN
        eRequestedManualMode := E_DS402OpMode.MCS2_OL_STEP_MODE;
    ELSIF stMotionStage.bHomeCmd THEN
        eRequestedManualMode := E_DS402OpMode.HOME;
    ELSIF stMotionStage.stMCS2ChanParams.bCalibrationCmd THEN
        eRequestedManualMode := E_DS402OpMode.MCS2_CALIBRATION;
    ELSIF stMotionStage.bMoveCmd THEN
        eRequestedManualMode := E_DS402OpMode.CSP;
    END_IF

    // -- Check if we are already in the requested mode --
    IF stDS402Drive.nModeOfOperationDisplay = eRequestedManualMode THEN
        // Already in mode:
        IF eRequestedManualMode <> E_DS402OpMode.CSP THEN
            // If we're in a manual mode and statemachine isn't operational, trigger statemachine with reset
            IF NOT bOperational THEN
                stDS402Drive.nDS402DriveControl.7 := TRUE; // Trigger state machine reset
                bManualTransition := TRUE;
            END_IF
        END_IF
        bPendingManualModeSwitch := FALSE;
    ELSE
        // -- If switching to CSP, just switch mode (NC handles MC_Power) --
        IF eRequestedManualMode = E_DS402OpMode.CSP THEN
            stDS402Drive.nModeOfOperation := E_DS402OpMode.CSP;
            bPendingManualModeSwitch := FALSE;
        ELSE
            // -- Switching to a manual mode --
            IF stDS402Drive.nDS402DriveControl.4 THEN
                stDS402Drive.nDS402DriveControl.4 := FALSE; // Clear closed-loop latch
                bPendingManualModeSwitch := TRUE;
            ELSE
                stDS402Drive.nModeOfOperation := eRequestedManualMode;
                bPendingManualModeSwitch := TRUE;
            END_IF
        END_IF
    END_IF
END_IF

// === If pending switch to manual mode ===
IF bPendingManualModeSwitch THEN
    // Keep requesting mode until feedback matches
    stDS402Drive.nModeOfOperation := eRequestedManualMode;

    IF stDS402Drive.nModeOfOperationDisplay = eRequestedManualMode THEN
        // When drive feedback matches, trigger the state machine
        stDS402Drive.nDS402DriveControl.7 := TRUE;
        bManualTransition := TRUE;
        bPendingManualModeSwitch := FALSE;
    END_IF
END_IF

bDS402Manual := (stDS402Drive.nModeOfOperationDisplay <> E_DS402OpMode.CSP);

StateMachine(Enable := bManualTransition);]]></ST>
      </Implementation>
    </Method>
    <Method Name="MotionEndPowerDisable" Id="{20c015e9-bf00-4308-96ac-d493b364e91d}">
      <Declaration><![CDATA[METHOD PRIVATE MotionEndPowerDisable : BOOL
VAR_INST
    rtAbortedHome        : R_TRIG;
    rtAbortedStepMove    : R_TRIG;
    rtAbortedCalibration : R_TRIG;
    rtResetDone          : R_TRIG;
    rtHaltDone           : R_TRIG;
    rtMoveDone           : R_TRIG;
    rtHomeDone           : R_TRIG;
    rtStepMoveDone       : R_TRIG;
    rtCalibrationDone    : R_TRIG;
    ftEnableFallEdge     : F_TRIG;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[rtAbortedHome(CLK := bHomeAborted);
rtAbortedStepMove(CLK := bStepMoveAborted);
rtAbortedCalibration(CLK := bCalibrationAborted);

rtResetDone(CLK := fbMcReset.Done);
rtHaltDone(CLK := fbMcHalt.Done);

rtMoveDone(CLK := fbMcMoveAbsolute.Done);
rtHomeDone(CLK := bHomeDone);
rtStepMoveDone(CLK := bStepMoveDone);
rtCalibrationDone(CLK := bCalibrateMoveDone);

IF rtAbortedHome.Q OR rtAbortedStepMove.Q OR rtAbortedCalibration.Q
   OR rtResetDone.Q OR rtHaltDone.Q
   OR rtMoveDone.Q OR rtHomeDone.Q OR rtStepMoveDone.Q OR rtCalibrationDone.Q THEN

    IF NOT stMotionStage.bDone THEN
        stMotionStage.bExecute := FALSE;
        bCommandMoveAbsolute := FALSE;
        stMotionStage.bHomed := bHomeDone;
        IF rtMoveDone.Q THEN
            stMotionStage.bDone := TRUE;
            eDoneCause := E_MoveDoneCause.MoveDone;
        ELSIF rtStepMoveDone.Q THEN
            stMotionStage.bDone := TRUE;
            eDoneCause := E_MoveDoneCause.StepMoveDone;
        ELSIF rtHomeDone.Q THEN
            stMotionStage.bDone := TRUE;
            eDoneCause := E_MoveDoneCause.HomeDone;
        ELSIF rtCalibrationDone.Q THEN
            stMotionStage.bDone := TRUE;
            eDoneCause := E_MoveDoneCause.CalibrationDone;
        ELSIF rtResetDone.Q THEN
            stMotionStage.bDone := TRUE;
            eDoneCause := E_MoveDoneCause.ResetDone;
        ELSIF rtHaltDone.Q THEN
            stMotionStage.bDone := TRUE;
            eDoneCause := E_MoveDoneCause.HaltDone;
        ELSIF rtAbortedHome.Q THEN
            stMotionStage.bDone := TRUE;
            eDoneCause := E_MoveDoneCause.AbortedHome;
        ELSIF rtAbortedStepMove.Q THEN
            stMotionStage.bDone := TRUE;
            eDoneCause := E_MoveDoneCause.AbortedStepMove;
        ELSIF rtAbortedCalibration.Q THEN
            stMotionStage.bDone := TRUE;
            eDoneCause := E_MoveDoneCause.AbortedCalibration;
        END_IF
        IF bDS402Manual THEN
            bEnPosLag := FALSE;
        END_IF
        bLimOverride := FALSE;
        bHomeAborted := FALSE;
        bStepMoveAborted := FALSE;
        bCalibrationAborted := FALSE;
        bManualTransition := FALSE;
        bReset := FALSE;
        bHalt := FALSE;
        bPositionHold := TRUE;
        tonHoldTime.IN := TRUE;
    END_IF
END_IF

tonHoldTime(PT := UDINT_TO_TIME(stMotionStage.stMCS2ChanParams.nHoldTime));
IF tonHoldTime.Q THEN
    bPositionHold := FALSE;
    tonHoldTime.IN := FALSE;
    bLastHoltTimeOut := TRUE;
END_IF

(* updated axis status
   Not needed in manual mode *)
IF NOT bDS402Manual THEN
     stMotionStage.Axis.ReadStatus();
END_IF

bPrepareDisable S= (stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION) AND ftExec.Q;

IF bPrepareDisable AND bCSPModeEnabled THEN
    IF stMotionStage.Axis.Status.StandStill THEN
        IF NOT bPositionHold THEN
            bPrepareDisable := FALSE;
            stMotionStage.bEnable := FALSE; // TwinCAT NC disables MC_Power (CSP)
        END_IF
    END_IF
ELSIF bPrepareDisable AND bDS402Manual THEN
    IF bOperational THEN
        IF NOT bPositionHold THEN
            bPrepareDisable := FALSE;
            stMotionStage.bEnable := FALSE; // Manual disables via drive control word
        END_IF
    END_IF
END_IF

ftEnableFallEdge(CLK := stMotionStage.bEnable);
IF ftEnableFallEdge.Q THEN
    IF bDS402Manual THEN
        stDS402Drive.nDS402DriveControl := 6; // Manual mode power off
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveAbsolute" Id="{c9986ba7-a025-4f1a-8312-93dc4112a24c}">
      <Declaration><![CDATA[METHOD PUBLIC  MoveAbsolute
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMcMoveAbsolute(
    Axis :=  stMotionStage.Axis,
    Execute := bCommandMoveAbsolute,
    Position :=  stMotionStage.fPosition,
    Velocity :=  stMotionStage.fVelocity,
    Acceleration :=  stMotionStage.fAcceleration,
    Deceleration :=  stMotionStage.fDeceleration,
    BufferMode := eBufferMode,
);

IF fbMcMoveAbsolute.Done (*OR fbMcReset.Done*) THEN
    (*Hold the position in close loop before dropping power, a positional drift will occur then*)
    IF ( stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION ) THEN
        bPositionHold := TRUE;
        tonHoldTime.IN:=TRUE;
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="PersistParameters" Id="{827e19b0-eb90-45f1-a0f0-e397f2f834ae}">
      <Declaration><![CDATA[METHOD PersistParameters
VAR_INPUT
    Enable  : BOOL;
END_VAR

VAR_INST
    {attribute 'hide'}
    bEncError           : BOOL;

    {attribute 'hide'}
    bRestoreWaitRetry   : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Save Encoder position
// needs some pre-conditions to use persistent storage
IF Enable THEN
    // Check ST_MotionStage for an encoder error (range 0x44nn)
    bEncError:=  stMotionStage.Axis.Status.Error AND  (  stMotionStage.Axis.Status.ErrorID  >= 16#4400  AND  stMotionStage.Axis.Status.ErrorID <= 16#44FF );
    // Do not save if we're currently loading or if there is an encoder error
    IF NOT bRestoreLoad AND NOT bEncError AND NOT bRestoreWaitRetry THEN
        fSavedPosition :=  stMotionStage.Axis.NcToPlc.ActPos;
        // This persistent variable lets us check if anything was saved
        // It will be TRUE at startup if we have saved values
        bSaved := TRUE;
        (*
            use this with a timer of a change threshold on the fActPosition
            to trigger a save from this PLC program. otherwise this will be a spamming
            persistence, filling up the disk.
        *)
        //iPersistentDataStorage.TriggerWriteOfPersistentData := bSaveEnabled;
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="PostInit" Id="{7af64fe1-72e2-4a67-9fd4-3933db27c0b4}">
      <Declaration><![CDATA[{attribute 'call_after_init'}
(*  eModule: Mandatory must be unique for each MCS2 axis
    clears startup errors or warnings. the process is completed at run time
    SDO update of Drive and open Loop parameter Indexes based on module number
*)
METHOD PostInit
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* SDO update of Drive and open Loop parameter Indexes based on module number *)
nChanErrorCodeIdx        := nErrorCodeBase         + ((eModule-1) * nChanOfsBase);
nChanFErrWinIdx          := nFErrWinBase           + ((eModule-1) * nChanOfsBase);
nChanSoftLimitIdx        := nChanSoftLimitBase     + ((eModule-1) * nChanOfsBase);
nChanHomeOffsIdx         := nHomeOffsetBase        + ((eModule-1) * nChanOfsBase);
nChanHomeVeloIdx         := nHomingSpeedBase       + ((eModule-1) * nChanOfsBase);
nChanhomeAccIdx          := nhomingAccBase         + ((eModule-1) * nChanOfsBase);
nChanStepIdx             := nOlStepBase            + ((eModule-1) * nChanOfsBase);
nChanStepFreqIdx         := nOlStepFreqBase        + ((eModule-1) * nChanOfsBase);
nChanStepAmpIdx          := nOlStepAmpBase         + ((eModule-1) * nChanOfsBase);
nMaxCloseLoopFreqIdx     := nMaxCloseLoopFreqBase  + ((eModule-1) * nChanOfsBase);
nPositionerTypeIdx       := nPositionerTypeBase    + ((eModule-1) * nChanOfsBase);
nCalibrationOptIdx       := nCalibrationOptBase    + ((eModule-1) * nChanOfsBase);
nSensorPowerModeIdx      := nSensorPowerModeBase   + ((eModule-1) * nChanOfsBase);
nReferencingOptIdx       := nReferencingOptBase    + ((eModule-1) * nChanOfsBase);
nReferenceTypeIdx        := nReferenceTypeBase     + ((eModule-1) * nChanOfsBase);
nSafeDirIdx              := nSafeDirBase           + ((eModule-1) * nChanOfsBase);
nMotorLoadIdx            := nMotorLoadBase         + ((eModule-1) * nChanOfsBase);
nChannelTypeIdx          := nChannelTypeBase       + ((eModule-1) * nChanOfsBase);
nChannelStateIdx         := nChannelStateBase      + ((eModule-1) * nChanOfsBase);
nLogicalScaleOffsetIdx   := nLogicalScaleOffsetBase+ ((eModule-1) * nChanOfsBase);
nLogicalScaleInvIdx      := nLogicalScaleInvBase   + ((eModule-1) * nChanOfsBase);
bSystemInit := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Power" Id="{f641a677-a472-4a34-a0e0-f26f3662273e}">
      <Declaration><![CDATA[METHOD Power : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMcPower(
    Axis :=  stMotionStage.Axis,
    Enable :=  stMotionStage.bAllEnable(* AND bCSPModeEnabled*),
    Enable_Positive :=  stMotionStage.bAllForwardEnable,
    Enable_Negative :=  stMotionStage.bAllBackwardEnable,
    Override := 100.0,
    BufferMode := eBufferMode
);]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadChanParams" Id="{38e016e1-0871-4b70-80ed-51650e23542a}">
      <Declaration><![CDATA[METHOD PRIVATE ReadChanParams
VAR_INST
    tonSDOReadTrigger          : TON;
    bSDOReadTrigger            : BOOL;
    fbMaxCloseLoopFreqRead     : FB_EcCoESdoRead;
    fbPositionerTypeRead       : FB_EcCoESdoRead;
    fbCalibrationOptRead       : FB_EcCoESdoRead;
    fbSensorPowerModeRead      : FB_EcCoESdoRead;
    fbReferencingOptRead       : FB_EcCoESdoRead;
    fbReferenceTypeRead        : FB_EcCoESdoRead;
    fbSafeDirRead              : FB_EcCoESdoRead;
    fbMotorLoadRead            : FB_EcCoESdoRead;
    fbChannelTypeRead          : FB_EcCoESdoRead;
    fbChannelStateRead         : FB_EcCoESdoRead;
    fbLogicalScaleOffsetRead   : FB_EcCoESdoRead;
    fbLogicalScaleInvRead      : FB_EcCoESdoRead;
    ftMaxCloseLoopFreqRead      : F_TRIG;
    ftPositionerTypeRead        : F_TRIG;
    ftCalibrationOptRead        : F_TRIG;
    ftSensorPowerModeRead       : F_TRIG;
    ftReferencingOptRead        : F_TRIG;
    ftSafeDirRead               : F_TRIG;
    ftMotorLoadRead             : F_TRIG;
    ftChannelTypeRead           : F_TRIG;
    ftChannelStateRead          : F_TRIG;
    ftLogicalScaleOffsetRead    : F_TRIG;

END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// ----- 1s Timer to trigger all SDO reads -----
tonSDOReadTrigger(IN:=TRUE, PT:=T#1s);

IF tonSDOReadTrigger.Q THEN
    tonSDOReadTrigger(IN:=FALSE); // Reset timer; we want a pulse
    bSDOReadTrigger := TRUE;
ELSE
    bSDOReadTrigger := FALSE;
END_IF

// ----- SDO Reads, triggered together on the timer pulse -----

fbMaxCloseLoopFreqRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nMaxCloseLoopFreqIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMotionStage.stMCS2ChanParams.nMaxCloseLoopFreq),
    cbBufLen    := SIZEOF(stMotionStage.stMCS2ChanParams.nMaxCloseLoopFreq),
    bExecute    := bSDOReadTrigger
);

fbPositionerTypeRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nPositionerTypeIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMotionStage.stMCS2ChanParams.nPositionerType),
    cbBufLen    := SIZEOF(stMotionStage.stMCS2ChanParams.nPositionerType),
    bExecute    := bSDOReadTrigger
);

fbCalibrationOptRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nCalibrationOptIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMotionStage.stMCS2ChanParams.nCalibrationOpt),
    cbBufLen    := SIZEOF(stMotionStage.stMCS2ChanParams.nCalibrationOpt),
    bExecute    := bSDOReadTrigger
);

fbSensorPowerModeRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nSensorPowerModeIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMotionStage.stMCS2ChanParams.nSensorPowerMode),
    cbBufLen    := SIZEOF(stMotionStage.stMCS2ChanParams.nSensorPowerMode),
    bExecute    := bSDOReadTrigger
);

fbReferencingOptRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nReferencingOptIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMotionStage.stMCS2ChanParams.nReferencingOpt),
    cbBufLen    := SIZEOF(stMotionStage.stMCS2ChanParams.nReferencingOpt),
    bExecute    := bSDOReadTrigger
);

fbReferenceTypeRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nReferenceTypeIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMotionStage.stMCS2ChanParams.nReferenceType),
    cbBufLen    := SIZEOF(stMotionStage.stMCS2ChanParams.nReferenceType),
    bExecute    := bSDOReadTrigger
);

fbSafeDirRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nSafeDirIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMotionStage.stMCS2ChanParams.nSafeDir),
    cbBufLen    := SIZEOF(stMotionStage.stMCS2ChanParams.nSafeDir),
    bExecute    := bSDOReadTrigger
);

fbMotorLoadRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nMotorLoadIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMotionStage.stMCS2ChanParams.nMotorLoad),
    cbBufLen    := SIZEOF(stMotionStage.stMCS2ChanParams.nMotorLoad),
    bExecute    := bSDOReadTrigger
);

fbChannelTypeRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nChannelTypeIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMotionStage.stMCS2ChanParams.nChannelType),
    cbBufLen    := SIZEOF(stMotionStage.stMCS2ChanParams.nChannelType),
    bExecute    := bSDOReadTrigger
);

fbChannelStateRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nChannelStateIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMotionStage.stMCS2ChanParams.stChannelState.dwRaw),
    cbBufLen    := SIZEOF(stMotionStage.stMCS2ChanParams.stChannelState.dwRaw),
    bExecute    := bSDOReadTrigger
);

fbLogicalScaleOffsetRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nLogicalScaleOffsetIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMotionStage.stMCS2ChanParams.nLogicalScaleOffset),
    cbBufLen    := SIZEOF(stMotionStage.stMCS2ChanParams.nLogicalScaleOffset),
    bExecute    := bSDOReadTrigger
);

fbLogicalScaleInvRead(
    sNetId      := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr  := stDS402Drive.nSlaveAddr,
    nIndex      := nLogicalScaleInvIdx,
    nSubIndex   := 0,
    pDstBuf     := ADR(stMotionStage.stMCS2ChanParams.nLogicalScaleInv),
    cbBufLen    := SIZEOF(stMotionStage.stMCS2ChanParams.nLogicalScaleInv),
    bExecute    := bSDOReadTrigger
);

// --- Error logic: Only act if axis is NOT busy, and SDO read failed ---
ftChannelStateRead(CLK := fbChannelStateRead.bBusy);
IF ftChannelStateRead.Q THEN
    IF NOT fbChannelStateRead.bError THEN
        // After SDO read, decode bits to booleans:
        stMotionStage.stMCS2ChanParams.stChannelState.bActivelyMoving        := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00000001) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bClosedLoopActive      := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00000002) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bCalibrating           := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00000004) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bReferencing           := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00000008) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bMoveDelayed           := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00000010) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bSensorPresent         := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00000020) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bIsCalibrated          := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00000040) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bIsReferenced          := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00000080) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bEndStopReached        := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00000100) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bRangeLimitReached     := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00000200) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bFollowingLimitReached := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00000400) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bMovementFailed        := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00000800) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bIsStreaming           := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00001000) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bPositionerOverload    := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00002000) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bOverTemperature       := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00004000) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bReferenceMark         := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00008000) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bIsPhased              := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00010000) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bPositionerFault       := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00020000) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bAmplifierEnabled      := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00040000) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bInPosition            := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00080000) <> 0;
        stMotionStage.stMCS2ChanParams.stChannelState.bBrakeEnabled          := (stMotionStage.stMCS2ChanParams.stChannelState.dwRaw AND 16#00100000) <> 0;
    ELSE
        IF NOT stMotionStage.bBusy THEN
            // --- Error condition (write your own handling here) ---
            stMotionStage.bError := TRUE;  // Set your own error flag
            stMotionStage.sErrorMessage := 'Failed to read ChannelState';
        END_IF
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadDriveCodes" Id="{c8b026c7-a02a-444a-a6c8-2fcd1b30b9c5}">
      <Declaration><![CDATA[(* Read Drive error codes after a motion or fault condition occured *)
METHOD ReadDriveCodes : BOOL
VAR_INST
    {attribute 'hide'}
    fbErrorRead         : FB_EcCoESdoRead;
    {attribute 'hide'}
    nPiezoErrorCode     : UDINT;
    {attribute 'hide'}
    fbLogError          : FB_LogMotionError;
    {attribute 'hide'}
    ftErrorReadDone     : F_TRIG;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbErrorRead( sNetId:= THIS^.stMotionStage.stAxisParameters.sAmsNetId,
             nSlaveAddr:=stDS402Drive.nSlaveAddr,
             nIndex:=nChanErrorCodeIdx,
             nSubIndex :=nSubIndex,
             pDstBuf:= ADR(nPiezoErrorCode),
             cbBufLen:=SIZEOF(nPiezoErrorCode),
             bExecute:= stMotionStage.bError );

ftErrorReadDone(CLK:=fbErrorRead.bBusy);
IF ftErrorReadDone.Q THEN
    IF  NOT fbErrorRead.bError AND nPiezoErrorCode <> 0 THEN
        stMotionStage.nErrorId := nPiezoErrorCode;
    END_IF
    stMotionStage.sErrorMessage := F_MotionErrorCodeLookup(nErrorId:=stMotionStage.nErrorId);
    fbLogError( stMotionStage:=stMotionStage, bEnable:=stMotionStage.bError);
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Reset" Id="{643b4736-0a43-4a18-8f6b-8a2439ed5e6f}">
      <Declaration><![CDATA[METHOD Reset : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMcReset(
    Axis :=  stMotionStage.Axis,
    Execute := bReset
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="RestoreMotionParams" Id="{8335d215-fac8-43bf-97f2-e08acc164700}">
      <Declaration><![CDATA[METHOD RestoreMotionParams
VAR_INPUT
    Enable  : BOOL;
END_VAR

VAR_INST
    {attribute 'hide'}
    fbSetPos            : MC_SetPosition;
    {attribute 'hide'}
    bLoad               : BOOL;
    {attribute 'hide'}
    bRestoreDone        : BOOL;
    {attribute 'hide'}
    bRestoreInit        : BOOL;
    {attribute 'hide'}
    bRestoreWaitRetry   : BOOL;
    {attribute 'hide'}
    nMaxRetries         : UINT := 10;
    {attribute 'hide'}
    nCurrTries          : UINT := 0;
    {attribute 'hide'}
    nLatchError         : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Enable THEN
    // Trigger a load if anything was saved at all
    IF NOT bRestoreInit THEN
        bRestoreInit := TRUE;
        bRestoreLoad S= bSaved;
        fbSetPos.Options.ClearPositionLag := TRUE;
    END_IF

    // Set our position if bRestoreLoad is true
    fbSetPos( Axis:= stMotionStage.Axis, Execute:=bRestoreLoad, Position:=fSavedPosition);

    // Only load once, at startup
    bRestoreLoad R= fbSetPos.Done OR fbSetPos.Error;

    IF fbSetPos.Error THEN
        // Keep the error latched, it can disappear if Execute is set to FALSE
        nLatchError := fbSetPos.ErrorID;
        nCurrTries := nCurrTries + 1;
        IF nCurrTries >= nMaxRetries THEN
        // Alert the user that something has gone wrong
         stMotionStage.bError := TRUE;
         stMotionStage.nErrorId := nLatchError;
         stMotionStage.sCustomErrorMessage := 'Error loading previously saved position.';
        ELSE
            // Reset the FB for the next retry
            fbSetPos( Axis:= stMotionStage.Axis, Execute:=bRestoreLoad, Position:=fSavedPosition);
            // Try again
            bRestoreWaitRetry := TRUE;
        END_IF
    ELSE
        IF NOT bRestoreDone THEN
             stMotionStage.fPosition := fSavedPosition;
        END_IF
        bRestoreDone := TRUE;
    END_IF

    tonRestoreRetry( IN := bRestoreWaitRetry, PT := T#100MS);
    bRestoreLoad S= tonRestoreRetry.Q;
    bRestoreWaitRetry R= tonRestoreRetry.Q;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ScaleDriveParams" Id="{b413f5fa-ba01-446e-8e58-be0ddf41b7f7}">
      <Declaration><![CDATA[METHOD ScaleDriveParams
]]></Declaration>
      <Implementation>
        <ST><![CDATA[nScaledFErrWin:=LREAL_TO_DINT(( stMotionStage.stAxisParameters.fCtrlPosDiffMax / MAX( stMotionStage.stAxisParameters.fEncScaleFactorInternal, stMotionStage.stMCS2ChanParams.fScalingFactor)));

IF  stMotionStage.stAxisParameters.bEncEnableSoftEndMinControl.0 AND  stMotionStage.stAxisParameters.bEncEnableSoftEndMaxControl.0 THEN
    stMotionStage.stMCS2ChanParams.nSoftLimMax := LREAL_TO_DINT(( stMotionStage.stAxisParameters.fEncSoftEndMax / MAX( stMotionStage.stAxisParameters.fEncScaleFactorInternal, stMotionStage.stMCS2ChanParams.fScalingFactor)));
    stMotionStage.stMCS2ChanParams.nSoftLimMin := LREAL_TO_DINT(( stMotionStage.stAxisParameters.fEncSoftEndMin / MAX( stMotionStage.stAxisParameters.fEncScaleFactorInternal, stMotionStage.stMCS2ChanParams.fScalingFactor)));
ELSE
    // Soft limit disabled
    stMotionStage.stMCS2ChanParams.nSoftLimMax := 0;
    stMotionStage.stMCS2ChanParams.nSoftLimMin := 0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ScaleEncRawValue" Id="{769f98a6-388a-461f-854a-93b1758d578f}">
      <Declaration><![CDATA[METHOD ScaleEncRawValue
VAR_INPUT
  //  bEnable: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* SmartACT: The encoder count from the Piezo drive is not a raw count from the embeded actuator device
   we get a calibrated nm value. thus the use of abs() since this value is signed.
   PI: to be discovered *)
IF  stMotionStage.nRawEncoderDINT <> 0 THEN
     stMotionStage.nEncoderCount:=DINT_TO_UDINT(ABS( stMotionStage.nRawEncoderDINT));
ELSE
     stMotionStage.nEncoderCount:=0;
END_IF

// calibrated encoder readback
IF NOT bStepModeEnabled THEN
    // Close loop NC
    fMeasuredPos:= stMotionStage.Axis.NcToPlc.ActPos;
    fMeasuredVelo := stMotionStage.Axis.NcToPlc.ActVelo;
    fMeasuredAcc :=  stMotionStage.Axis.NcToPlc.ActAcc;
     stMotionStage.fPosDiff:= stMotionStage.Axis.NcToPlc.PosDiff;
ELSE
    fMeasuredPos:=DINT_TO_REAL( stMotionStage.nRawEncoderDINT) * MAX( stMotionStage.stAxisParameters.fEncScaleFactorInternal, stMotionStage.stMCS2ChanParams.fScalingFactor);
     stMotionStage.fPosDiff:= stMotionStage.fPosition - fMeasuredPos;
    // NB: Not actual in open loop
    fMeasuredVelo := stMotionStage.fVelocity;
    fMeasuredAcc :=  stMotionStage.fAcceleration;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="ScaleHomingParams" Id="{2c5b56b0-7eaa-4a13-8084-de781b4be994}">
      <Declaration><![CDATA[(*Scale Home Move parameters*)
METHOD ScaleHomingParams
]]></Declaration>
      <Implementation>
        <ST><![CDATA[stMotionStage.stMCS2ChanParams.nHomeVeloFast := LREAL_TO_UDINT(( stMotionStage.stAxisParameters.fRefVeloSearch / MAX( stMotionStage.stAxisParameters.fEncScaleFactorInternal, stMotionStage.stMCS2ChanParams.fScalingFactor)));
stMotionStage.stMCS2ChanParams.nHomeVeloSlow := LREAL_TO_UDINT(( stMotionStage.stAxisParameters.fRefVeloSync / MAX( stMotionStage.stAxisParameters.fEncScaleFactorInternal, stMotionStage.stMCS2ChanParams.fScalingFactor)));
stMotionStage.stMCS2ChanParams.nHomeAcc := LREAL_TO_UDINT((stMotionStage.stMCS2ChanParams.fHomeAcc / MAX( stMotionStage.stAxisParameters.fEncScaleFactorInternal, stMotionStage.stMCS2ChanParams.fScalingFactor)));
stMotionStage.stMCS2ChanParams.nHomeOffset := LREAL_TO_DINT(( stMotionStage.fHomePosition / MAX( stMotionStage.stAxisParameters.fEncScaleFactorInternal, stMotionStage.stMCS2ChanParams.fScalingFactor)));
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ScaleJogParams" Id="{78ce5a79-ef3b-44af-a794-7ac04154475b}">
      <Declaration><![CDATA[(*Scaled Open Loop Step mode motion parameters*)
METHOD ScaleJogParams
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF     stMotionStage.stMCS2ChanParams.nChanStepAmp = 0
    OR stMotionStage.stMCS2ChanParams.nChanStepFreq = 0 THEN
    bWrongParameter := TRUE;
ELSE
//     fScalededSteps := (THIS^.stMotionStage.fPosition * stMotionStage.stMCS2ChanParams.nChanStepEgu) ;
//     nScalededSteps:=LIMIT(-1000, LREAL_TO_DINT(fScalededSteps), 1000);
    nScalededSteps:=LIMIT(-1000, stMotionStage.stMCS2ChanParams.nChanStep, 1000);
    nScalededStepAmp:=REAL_TO_UINT(LIMIT(50, stMotionStage.stMCS2ChanParams.nChanStepAmp, 100) * 655.35);
    nScaledStepFreq:=REAL_TO_UINT(LIMIT(500, stMotionStage.stMCS2ChanParams.nChanStepFreq, 1000.0));
    bWrongParameter := FALSE;
END_IF
//827.31x-837.63]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetCalibrationParams" Id="{ca87540c-56e0-4ac6-9006-f00c40b88117}">
      <Declaration><![CDATA[METHOD SetCalibrationParams
VAR_INPUT
    Enable : BOOL;
END_VAR
VAR_INST
    {attribute 'hide'}
    fbSafeDirWrite              : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbChannelTypeWrite          : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbPositionerTypeWrite       : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbCalibrationOptWrite       : FB_EcCoESdoWrite;
    {attribute 'hide'}
    ftPositionerTypeSetDone     : F_TRIG;
    {attribute 'hide'}
    ftCalibrationOptSetDone     : F_TRIG;
    {attribute 'hide'}
    ftSafeDirSetDone            : F_TRIG;
    {attribute 'hide'}
    ftChannelTypeSetDone        : F_TRIG;
    {attribute 'hide'}
    nRecentPositionerType       : UDINT;
    {attribute 'hide'}
    nRecentCalibrationOpt       : UDINT;
    {attribute 'hide'}
    nRecentSafeDir              : BOOL;
    {attribute 'hide'}
    nRecentChannelType          : UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Enable THEN

    fbCalibrationOptWrite(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nCalibrationOptIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(stMotionStage.stMCS2ChanParams.nCalibrationOpt),
        cbBufLen   := SIZEOF(stMotionStage.stMCS2ChanParams.nCalibrationOpt),
        bExecute   := NOT stMotionStage.stMCS2ChanParams.stChannelState.bIsCalibrated AND (stMotionStage.stMCS2ChanParams.nCalibrationOpt  <> nRecentCalibrationOpt)
    );

    ftCalibrationOptSetDone(CLK:=fbCalibrationOptWrite.bBusy);
    bCalibrationsParamsSet  R= fbCalibrationOptWrite.bBusy;

    IF ftCalibrationOptSetDone.Q   OR ftChannelTypeSetDone.Q THEN
        IF fbCalibrationOptWrite.bError THEN
             stMotionStage.bError := fbCalibrationOptWrite.bError;
             stMotionStage.nErrorId := fbCalibrationOptWrite.nErrId;
        ELSE
            nRecentCalibrationOpt    := stMotionStage.stMCS2ChanParams.nCalibrationOpt;
            bCalibrationsParamsSet S= TRUE;
        END_IF
        fbCalibrationOptWrite.bExecute := FALSE;
     END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetChanParams" Id="{bba7eb59-9b08-4212-8ebb-7515fbf84d2c}">
      <Declaration><![CDATA[(*  Drive parameters update
    Mirror NC axis parameters configurations to those of MCS2 drive
    1- Following error
    2- Home Speeds
    3- Home Acceleration
    4- SoftLimits
*)
METHOD SetChanParams
VAR_INPUT
    Enable : BOOL;
END_VAR

VAR_INST
    {attribute 'hide'}
    fbSetFErrorWin              : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbSetSoftLimMin             : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbSetSoftLimMax             : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbMaxCloseLoopFreqWrite     : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbSensorPowerModeWrite      : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbLogicalScaleOffsetWrite   : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbLogicalScaleInvWrite      : FB_EcCoESdoWrite;
    {attribute 'hide'}
    nRecentSoftLimMax           : LINT;
    {attribute 'hide'}
    nRecentSoftLimMin           : LINT;
    {attribute 'hide'}
    nRecentFErrWin              : DINT;

    {attribute 'hide'}
    nRecentMaxCloseLoopFreq     : UDINT;
    {attribute 'hide'}
    nRecentSensorPowerMode      : UDINT;
    {attribute 'hide'}
    nRecentLogicalScaleOffset   : LINT;
    {attribute 'hide'}
    nRecentLogicalScaleInv      : BOOL;
    {attribute 'hide'}
    ftFErrWinSetDone            : F_TRIG;
    {attribute 'hide'}
    ftSoftLimMaxSetDone         : F_TRIG;
    {attribute 'hide'}
    ftSoftLimMinSetDone         : F_TRIG;
    {attribute 'hide'}
    ftMaxCloseLoopFreqSetDone   : F_TRIG;
    {attribute 'hide'}
    ftSensorPowerModeSetDone    : F_TRIG;
    {attribute 'hide'}
    ftLogicalScaleOffsetSetDone : F_TRIG;
    {attribute 'hide'}
    ftLogicalScaleInvSetDone : F_TRIG;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Enable THEN

    (*  Drive parameters update
        Mirror NC axis parameters configurations to those of MCS2 drive
        1- Following error.
        2- SoftLimits
        3-Position Range
    *)
    ScaleDriveParams();
    // 1. Main drive SDO writes
    fbSetFErrorWin(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nChanFErrWinIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(nScaledFErrWin),
        cbBufLen   := SIZEOF(nScaledFErrWin),
        bExecute   := (nScaledFErrWin <> nRecentFErrWin)
    );
    fbSetSoftLimMin(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nChanSoftLimitIdx,
        nSubIndex  := 1,
        pSrcBuf    := ADR(stMotionStage.stMCS2ChanParams.nSoftLimMin),
        cbBufLen   := SIZEOF(stMotionStage.stMCS2ChanParams.nSoftLimMin),
        bExecute   := (stMotionStage.stMCS2ChanParams.nSoftLimMin <> nRecentSoftLimMin)
    );
    fbSetSoftLimMax(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nChanSoftLimitIdx,
        nSubIndex  := 2,
        pSrcBuf    := ADR(stMotionStage.stMCS2ChanParams.nSoftLimMax),
        cbBufLen   := SIZEOF(stMotionStage.stMCS2ChanParams.nSoftLimMax),
        bExecute   := (stMotionStage.stMCS2ChanParams.nSoftLimMax <> nRecentSoftLimMax)
    );
    // 2. Extended parameters SDO writes
    fbMaxCloseLoopFreqWrite(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nMaxCloseLoopFreqIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(stMotionStage.stMCS2ChanParams.nMaxCloseLoopFreq),
        cbBufLen   := SIZEOF(stMotionStage.stMCS2ChanParams.nMaxCloseLoopFreq),
        bExecute   := (stMotionStage.stMCS2ChanParams.nMaxCloseLoopFreq <> nRecentMaxCloseLoopFreq)
    );
    fbSensorPowerModeWrite(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nSensorPowerModeIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(stMotionStage.stMCS2ChanParams.nSensorPowerMode),
        cbBufLen   := SIZEOF(stMotionStage.stMCS2ChanParams.nSensorPowerMode),
        bExecute   := (stMotionStage.stMCS2ChanParams.nSensorPowerMode <> nRecentSensorPowerMode)
    );

    fbLogicalScaleOffsetWrite(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nLogicalScaleOffsetIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(stMotionStage.stMCS2ChanParams.nLogicalScaleOffset),
        cbBufLen   := SIZEOF(stMotionStage.stMCS2ChanParams.nLogicalScaleOffset),
        bExecute   := (stMotionStage.stMCS2ChanParams.nLogicalScaleOffset <> nRecentLogicalScaleOffset)
    );

    fbLogicalScaleInvWrite(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nLogicalScaleInvIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(stMotionStage.stMCS2ChanParams.nLogicalScaleInv),
        cbBufLen   := SIZEOF(stMotionStage.stMCS2ChanParams.nLogicalScaleInv),
        bExecute   := (stMotionStage.stMCS2ChanParams.nLogicalScaleInv <> nRecentLogicalScaleInv)
    );

    ftFErrWinSetDone(CLK:=fbSetFErrorWin.bBusy);
    ftSoftLimMaxSetDone(CLK:=fbSetSoftLimMax.bBusy);
    ftSoftLimMinSetDone(CLK:=fbSetSoftLimMin.bBusy);
    ftMaxCloseLoopFreqSetDone(CLK:=fbMaxCloseLoopFreqWrite.bBusy);
    ftSensorPowerModeSetDone(CLK:=fbSensorPowerModeWrite.bBusy);
    ftLogicalScaleOffsetSetDone(CLK:=fbLogicalScaleOffsetWrite.bBusy);
    ftLogicalScaleInvSetDone(CLK:=fbLogicalScaleInvWrite.bBusy);

    bChanParamsSet  R= fbSetFErrorWin.bBusy
                        OR fbSetSoftLimMax.bBusy
                        OR fbSetSoftLimMin.bBusy
                        OR fbMaxCloseLoopFreqWrite.bBusy
                        OR fbSensorPowerModeWrite.bBusy
                        OR fbLogicalScaleOffsetWrite.bBusy
                        OR fbLogicalScaleInvWrite.bBusy;

    IF ftFErrWinSetDone.Q
        OR ftSoftLimMaxSetDone.Q
        OR ftSoftLimMinSetDone.Q
        OR ftMaxCloseLoopFreqSetDone.Q
        OR ftLogicalScaleOffsetSetDone.Q
        OR ftSensorPowerModeSetDone.Q THEN

        // Error logic for all parameters (set error and id if any)
        IF fbSetFErrorWin.bError THEN
             stMotionStage.bError := fbSetFErrorWin.bError;
             stMotionStage.nErrorId := fbSetFErrorWin.nErrId;
        ELSIF fbSetSoftLimMin.bError THEN
             stMotionStage.bError := fbSetSoftLimMin.bError;
             stMotionStage.nErrorId := fbSetSoftLimMin.nErrId;
        ELSIF fbSetSoftLimMax.bError THEN
             stMotionStage.bError := fbSetSoftLimMax.bError;
             stMotionStage.nErrorId := fbSetSoftLimMax.nErrId;
        ELSIF fbMaxCloseLoopFreqWrite.bError THEN
             stMotionStage.bError := fbMaxCloseLoopFreqWrite.bError;
             stMotionStage.nErrorId := fbMaxCloseLoopFreqWrite.nErrId;
        ELSIF fbSensorPowerModeWrite.bError THEN
             stMotionStage.bError := fbSensorPowerModeWrite.bError;
             stMotionStage.nErrorId := fbSensorPowerModeWrite.nErrId;
        ELSIF fbLogicalScaleOffsetWrite.bError THEN
             stMotionStage.bError := fbLogicalScaleOffsetWrite.bError;
             stMotionStage.nErrorId := fbLogicalScaleOffsetWrite.nErrId;
        ELSIF fbLogicalScaleInvWrite.bError THEN
             stMotionStage.bError := fbLogicalScaleInvWrite.bError;
             stMotionStage.nErrorId := fbLogicalScaleInvWrite.nErrId;
        ELSE
            nRecentFErrWin           := nScaledFErrWin;
            nRecentSoftLimMax        := stMotionStage.stMCS2ChanParams.nSoftLimMax;
            nRecentSoftLimMin        := stMotionStage.stMCS2ChanParams.nSoftLimMin;
            nRecentMaxCloseLoopFreq  := stMotionStage.stMCS2ChanParams.nMaxCloseLoopFreq;
            nRecentSensorPowerMode   := stMotionStage.stMCS2ChanParams.nSensorPowerMode;
            nRecentLogicalScaleOffset:= stMotionStage.stMCS2ChanParams.nLogicalScaleOffset;
            nRecentLogicalScaleInv   := stMotionStage.stMCS2ChanParams.nLogicalScaleInv;
            bChanParamsSet S=TRUE;
        END_IF
        fbSetFErrorWin.bExecute   := FALSE;
        fbSetSoftLimMin.bExecute  := FALSE;
        fbSetSoftLimMax.bExecute  := FALSE;
        fbMaxCloseLoopFreqWrite.bExecute  := FALSE;
        fbSensorPowerModeWrite.bExecute   := FALSE;
        fbLogicalScaleOffsetWrite.bExecute:= FALSE;
        fbLogicalScaleInvWrite.bExecute:= FALSE;
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetEnables" Id="{28f7e94e-bad4-40ca-b34a-f8da453343cc}">
      <Declaration><![CDATA[METHOD SetEnables
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[ stMotionStage.bAllForwardEnable:= stMotionStage.bLimitForwardEnable AND ( stMotionStage.bGantryForwardEnable OR NOT  stMotionStage.bGantryAxis) AND  stMotionStage.stEPSForwardEnable.bEPS_OK  AND  stMotionStage.bOverrideDirEnable;
 stMotionStage.bAllBackwardEnable:= stMotionStage.bLimitBackwardEnable AND ( stMotionStage.bGantryBackwardEnable OR NOT  stMotionStage.bGantryAxis) AND  stMotionStage.stEPSBackwardEnable.bEPS_OK  AND  stMotionStage.bOverrideDirEnable;

 stMotionStage.bAllEnable:= stMotionStage.bEnable AND  stMotionStage.bHardwareEnable AND  stMotionStage.stEPSPowerEnable.bEPS_OK;
 stMotionStage.bAllEnable R= NOT  stMotionStage.bUserEnable;]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetEpicsStatus" Id="{dc90c8f8-9d88-4ab9-9dc0-f90cd21b81fc}">
      <Declaration><![CDATA[METHOD SetEpicsStatus
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//////////////////////////////////////////////////////////////////
// Transfer NC parameter status to EPICS
//////////////////////////////////////////////////////////////////
 stMotionStage.nMotionAxisID :=  stMotionStage.Axis.NcToPlc.AxisId;
 stMotionStage.stAxisStatus.bEnable:= stMotionStage.bAllEnable;
 stMotionStage.stAxisStatus.bEnabled:= stMotionStage.bEnableDone; // account for PowerEnable from power block
 stMotionStage.stAxisStatus.bError:= stMotionStage.bError;
 stMotionStage.stAxisStatus.bHomeSensor:= stMotionStage.bHome;
 stMotionStage.stAxisStatus.bLimitBwd:= stMotionStage.bAllBackwardEnable;
 stMotionStage.stAxisStatus.bLimitFwd:= stMotionStage.bAllForwardEnable;
 stMotionStage.stAxisStatus.bReset:= stMotionStage.bReset;
 stMotionStage.stAxisStatus.fAcceleration:=fMeasuredAcc;
 stMotionStage.stAxisStatus.fActDiff:= stMotionStage.fPosDiff;
 stMotionStage.stAxisStatus.fActPosition:=fMeasuredPos;
 stMotionStage.stAxisStatus.fActVelocity:=fMeasuredVelo;
 stMotionStage.stAxisStatus.fDeceleration:=fMeasuredAcc;
 stMotionStage.stAxisStatus.fOverride:=fbMcPower.Override;
 stMotionStage.stAxisStatus.fPosition:= stMotionStage.fPosition;
 stMotionStage.stAxisStatus.fVelocity:= stMotionStage.fVelocity;
 stMotionStage.stAxisStatus.nCmdData:=INT_TO_UINT( stMotionStage.nCmdData);  //Or nCmdDataLocal
 stMotionStage.stAxisStatus.nCommand:=INT_TO_UINT( stMotionStage.nCommand);  //Or nCommandLocal
 stMotionStage.stAxisStatus.nErrorId:= stMotionStage.nErrorId;
 stMotionStage.stAxisStatus.bBusy:= stMotionStage.bBusy;
 stMotionStage.stAxisStatus.bHomed:= stMotionStage.bHomed;
 stMotionStage.stAxisStatus.bExecute:=bLocalExec;
 stMotionStage.stAxisStatus.nCommand:=3; // If this is not 3, the IOC stops updating positions during homing


]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetHomingParams" Id="{5f7d28d4-6499-4637-aa98-e69b72a3a9cb}">
      <Declaration><![CDATA[METHOD SetHomingParams : BOOL
VAR_INPUT
    Enable : BOOL;
END_VAR

VAR_INST
    {attribute 'hide'}
    fbSetHomeOffs               : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbSetHomeVeloFast           : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbSetHomeVeloSlow           : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbSetHomeAcc                : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbReferencingOptWrite       : FB_EcCoESdoWrite;
    {attribute 'hide'}
    ftHomeVeloFastSetDone       : F_TRIG;
    {attribute 'hide'}
    ftHomeAccSetDone            : F_TRIG;
    {attribute 'hide'}
    ftHomeOffsSetDone           : F_TRIG;
    {attribute 'hide'}
    ftHomeVeloSlowSetDone       : F_TRIG;
    {attribute 'hide'}
    ftReferencingOptSetDone     : F_TRIG;

    {attribute 'hide'}
    nRecentHomeVeloFast         : UDINT;
    {attribute 'hide'}
    nRecentHomeVeloSlow         : UDINT;
    {attribute 'hide'}
    nRecentHomeAcc              : UDINT;
    {attribute 'hide'}
    nRecentHomeOffset           : DINT;
    {attribute 'hide'}
    nRecentReferencingOpt       : UDINT;

    {attribute 'hide'}
    nHomeOffs                   : DINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Enable THEN
    ScaleHomingParams();

    fbSetHomeVeloFast(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nChanHomeVeloIdx,
        nSubIndex  := 1,
        pSrcBuf    := ADR(stMotionStage.stMCS2ChanParams.nHomeVeloFast),
        cbBufLen   := SIZEOF(stMotionStage.stMCS2ChanParams.nHomeVeloFast),
        bExecute   := (stMotionStage.stMCS2ChanParams.nHomeVeloFast <> nRecentHomeVeloFast)
    );
    fbSetHomeVeloSlow(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nChanHomeVeloIdx,
        nSubIndex  := 2,
        pSrcBuf    := ADR(stMotionStage.stMCS2ChanParams.nHomeVeloSlow),
        cbBufLen   := SIZEOF(stMotionStage.stMCS2ChanParams.nHomeVeloSlow),
        bExecute   := (stMotionStage.stMCS2ChanParams.nHomeVeloSlow <> nRecentHomeVeloSlow)
    );
    fbSetHomeAcc(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nChanhomeAccIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(stMotionStage.stMCS2ChanParams.nHomeAcc),
        cbBufLen   := SIZEOF(stMotionStage.stMCS2ChanParams.nHomeAcc),
        bExecute   := (stMotionStage.stMCS2ChanParams.nHomeAcc <> nRecentHomeAcc)
    );
    fbSetHomeOffs(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nChanHomeOffsIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(stMotionStage.stMCS2ChanParams.nHomeOffset),
        cbBufLen   := SIZEOF(stMotionStage.stMCS2ChanParams.nHomeOffset),
        bExecute   := (stMotionStage.stMCS2ChanParams.nHomeOffset <> nRecentHomeOffset)
    );
    fbReferencingOptWrite(
        sNetId     := THIS^.stMotionStage.stAxisParameters.sAmsNetId,
        nSlaveAddr := stDS402Drive.nSlaveAddr,
        nIndex     := nReferencingOptIdx,
        nSubIndex  := 0,
        pSrcBuf    := ADR(stMotionStage.stMCS2ChanParams.nReferencingOpt),
        cbBufLen   := SIZEOF(stMotionStage.stMCS2ChanParams.nReferencingOpt),
        bExecute   := NOT stMotionStage.stMCS2ChanParams.stChannelState.bIsReferenced AND (stMotionStage.stMCS2ChanParams.nReferencingOpt <> nRecentReferencingOpt)
    );


    ftHomeVeloFastSetDone(CLK:=fbSetHomeVeloFast.bBusy);
    ftHomeVeloSlowSetDone(CLK:=fbSetHomeVeloSlow.bBusy);
    ftHomeAccSetDone(CLK:=fbSetHomeAcc.bBusy);
    ftHomeOffsSetDone(CLK:=fbSetHomeOffs.bBusy);
    ftReferencingOptSetDone(CLK:=fbReferencingOptWrite.bBusy);

    bHomingParamsSet  R= fbSetHomeVeloFast.bBusy
                            OR fbSetHomeVeloSlow.bBusy
                            OR fbSetHomeAcc.bBusy
                            OR fbSetHomeOffs.bBusy
                            OR fbReferencingOptWrite.bBusy;

    IF ftHomeVeloFastSetDone.Q OR ftHomeVeloSlowSetDone.Q OR ftHomeAccSetDone.Q OR ftHomeOffsSetDone.Q
         OR ftReferencingOptSetDone.Q THEN

        // Error logic for all parameters (set error and id if any)
        IF fbSetHomeVeloFast.bError THEN
             stMotionStage.bError := fbSetHomeVeloFast.bError;
             stMotionStage.nErrorId := fbSetHomeVeloFast.nErrId;
        ELSIF fbSetHomeVeloSlow.bError THEN
             stMotionStage.bError := fbSetHomeVeloSlow.bError;
             stMotionStage.nErrorId := fbSetHomeVeloSlow.nErrId;
        ELSIF fbSetHomeAcc.bError THEN
             stMotionStage.bError := fbSetHomeAcc.bError;
             stMotionStage.nErrorId := fbSetHomeAcc.nErrId;
        ELSIF fbSetHomeOffs.bError THEN
             stMotionStage.bError := fbSetHomeOffs.bError;
             stMotionStage.nErrorId := fbSetHomeOffs.nErrId;
        ELSIF fbReferencingOptWrite.bError THEN
             stMotionStage.bError := fbReferencingOptWrite.bError;
             stMotionStage.nErrorId := fbReferencingOptWrite.nErrId;

        ELSE
            nRecentHomeVeloFast      := stMotionStage.stMCS2ChanParams.nHomeVeloFast;
            nRecentHomeVeloSlow      := stMotionStage.stMCS2ChanParams.nHomeVeloSlow;
            nRecentHomeAcc           := stMotionStage.stMCS2ChanParams.nHomeAcc;
            nRecentHomeOffset        := stMotionStage.stMCS2ChanParams.nHomeOffset;
            nRecentReferencingOpt    := stMotionStage.stMCS2ChanParams.nReferencingOpt;
            bHomingParamsSet S= TRUE;
        END_IF
        fbSetHomeVeloFast.bExecute := FALSE;
        fbSetHomeVeloSlow.bExecute := FALSE;
        fbSetHomeAcc.bExecute     := FALSE;
        fbSetHomeOffs.bExecute    := FALSE;
        fbReferencingOptWrite.bExecute    := FALSE;
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetJogParams" Id="{4e8302eb-f6c2-4802-bf37-2e40ea9fd85c}">
      <Declaration><![CDATA[(*  MCS2 OL Step parameters update
    1- Step
    2- Step Amplitude
    3- StepFreq
*)
METHOD SetJogParams
VAR_INPUT
    Enable : BOOL;
END_VAR

VAR_INST
    // Open Loop Operations
    {attribute 'hide'}
    fbSetSteps          : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbSetStepFreq       : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbSetStepAmp        : FB_EcCoESdoWrite;
    {attribute 'hide'}
    nRecentSteps        : DINT;
    {attribute 'hide'}
    nRecentStepAmp      : UINT;
    {attribute 'hide'}
    nRecentStepFreq     : UINT;
    {attribute 'hide'}
    ftStepAmpUpdateDone : F_TRIG;
    {attribute 'hide'}
    ftStepFreqUpdateDone    : F_TRIG;
    {attribute 'hide'}
    ftStepUpdateDone    : F_TRIG;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Enable THEN
  ScaleJogParams();

  fbSetSteps(
    sNetId     :=  stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr := stDS402Drive.nSlaveAddr,
    nIndex     := nChanStepIdx,
    nSubIndex  := 0,
    pSrcBuf    := ADR(nScalededSteps),
    cbBufLen   := SIZEOF(stMotionStage.stMCS2ChanParams.nChanStep),
    bExecute   := (nScalededSteps <> nRecentSteps)
  );
  fbSetStepAmp(
    sNetId     :=  stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr := stDS402Drive.nSlaveAddr,
    nIndex     := nChanStepAmpIdx,
    nSubIndex  := 0,
    pSrcBuf    := ADR(nScalededStepAmp),
    cbBufLen   := SIZEOF(stMotionStage.stMCS2ChanParams.nChanStepAmp),
    bExecute   := (nScalededStepAmp <> nRecentStepAmp)
  );
  fbSetStepFreq(
    sNetId     :=  stMotionStage.stAxisParameters.sAmsNetId,
    nSlaveAddr := stDS402Drive.nSlaveAddr,
    nIndex     := nChanStepFreqIdx,
    nSubIndex  := 0,
    pSrcBuf    := ADR(nScaledStepFreq),
    cbBufLen   := SIZEOF(stMotionStage.stMCS2ChanParams.nChanStepFreq),
    bExecute   := (nScaledStepFreq <> nRecentStepFreq)
  );
  ftStepUpdateDone(CLK:=fbSetSteps.bBusy);
  ftStepAmpUpdateDone(CLK:=fbSetStepAmp.bBusy);
  ftStepFreqUpdateDone(CLK:=fbSetStepFreq.bBusy);

    bStepModeParamsSet R= fbSetSteps.bBusy OR fbSetStepAmp.bBusy OR fbSetStepFreq.bBusy;
  IF ftStepUpdateDone.Q
        OR ftStepAmpUpdateDone.Q
        OR ftStepFreqUpdateDone.Q THEN
    IF fbSetSteps.bError THEN
             stMotionStage.bError := fbSetSteps.bError;
             stMotionStage.nErrorId := fbSetSteps.nErrId;
        ELSIF fbSetStepFreq.bError THEN
             stMotionStage.bError := fbSetStepFreq.bError;
             stMotionStage.nErrorId := fbSetStepFreq.nErrId;
        ELSIF fbSetStepAmp.bError THEN
             stMotionStage.bError := fbSetStepAmp.bError;
             stMotionStage.nErrorId := fbSetStepAmp.nErrId;
    ELSE
        nRecentSteps := nScalededSteps;
        nRecentStepAmp := nScalededStepAmp;
        nRecentStepFreq := nScaledStepFreq;
        bStepModeParamsSet S= TRUE;
    END_IF
        fbSetSteps.bExecute := FALSE;
        fbSetStepFreq.bExecute := FALSE;
        fbSetStepAmp.bExecute := FALSE;
    END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{08b990dd-982c-4d9b-9ed0-d47355966885}">
      <Declaration><![CDATA[METHOD StateMachine
VAR_INPUT
    Enable : BOOL;
END_VAR

VAR_INST
    rtFault: R_TRIG;
    {attribute 'hide'}
    bFault              : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Defaults: always reflect feedback if not driving outputs
bOperational := FALSE;
bFault := FALSE;

IF NOT Enable THEN
    // Only reflect current status; never write to control word
    IF     stDS402Drive.stDS402DriveStatus.ReadyToSwitchOn
        AND stDS402Drive.stDS402DriveStatus.SwitchedOn
        AND stDS402Drive.stDS402DriveStatus.OperationEnabled
        AND NOT stDS402Drive.stDS402DriveStatus.Fault
        AND stDS402Drive.stDS402DriveStatus.VoltageEnabled
        AND stDS402Drive.stDS402DriveStatus.QuickStopActive
        AND NOT stDS402Drive.stDS402DriveStatus.SwitchOnDisabled
    THEN
        bOperational := TRUE;
    ELSIF stDS402Drive.stDS402DriveStatus.Fault THEN
        bFault := TRUE;
    END_IF
ELSE
    // === Write state logic ONLY when Enable ===
    // --- SWITCH ON DISABLED ---
    IF NOT stDS402Drive.stDS402DriveStatus.ReadyToSwitchOn
        AND NOT stDS402Drive.stDS402DriveStatus.SwitchedOn
        AND NOT stDS402Drive.stDS402DriveStatus.OperationEnabled
        AND NOT stDS402Drive.stDS402DriveStatus.Fault
        AND stDS402Drive.stDS402DriveStatus.VoltageEnabled
        AND NOT stDS402Drive.stDS402DriveStatus.QuickStopActive
        AND stDS402Drive.stDS402DriveStatus.SwitchOnDisabled
    THEN
        bOperational := FALSE;

        bFault := FALSE;
        stDS402Drive.nDS402DriveControl := 6;    // 6 = shutdown

    // --- READY TO SWITCH ON ---
    ELSIF stDS402Drive.stDS402DriveStatus.ReadyToSwitchOn
        AND NOT stDS402Drive.stDS402DriveStatus.SwitchedOn
        AND NOT stDS402Drive.stDS402DriveStatus.OperationEnabled
        AND NOT stDS402Drive.stDS402DriveStatus.Fault
        AND stDS402Drive.stDS402DriveStatus.VoltageEnabled
        AND stDS402Drive.stDS402DriveStatus.QuickStopActive
        AND NOT stDS402Drive.stDS402DriveStatus.SwitchOnDisabled
    THEN
        bOperational := FALSE;
        bFault := FALSE;
        stDS402Drive.nDS402DriveControl := 7;     // 7 = switch on

    // --- SWITCHED ON (with quickstop) ---
    ELSIF stDS402Drive.stDS402DriveStatus.ReadyToSwitchOn
        AND  stDS402Drive.stDS402DriveStatus.SwitchedOn
        AND NOT stDS402Drive.stDS402DriveStatus.OperationEnabled
        AND NOT stDS402Drive.stDS402DriveStatus.Fault
        AND stDS402Drive.stDS402DriveStatus.VoltageEnabled
        AND stDS402Drive.stDS402DriveStatus.QuickStopActive
        AND NOT stDS402Drive.stDS402DriveStatus.SwitchOnDisabled
    THEN
        bOperational := FALSE;
        stDS402Drive.nDS402DriveControl := 15;    // 15 = enable operation

    // --- OPERATION ENABLED ---
    ELSIF stDS402Drive.stDS402DriveStatus.ReadyToSwitchOn
        AND stDS402Drive.stDS402DriveStatus.SwitchedOn
        AND stDS402Drive.stDS402DriveStatus.OperationEnabled
        AND NOT stDS402Drive.stDS402DriveStatus.Fault
        AND stDS402Drive.stDS402DriveStatus.VoltageEnabled
        AND stDS402Drive.stDS402DriveStatus.QuickStopActive
        AND NOT stDS402Drive.stDS402DriveStatus.SwitchOnDisabled
    THEN
        bManualTransition := FALSE;
        bOperational := TRUE;

    // --- FAULT STATE ---
    ELSIF NOT stDS402Drive.stDS402DriveStatus.ReadyToSwitchOn
        AND NOT stDS402Drive.stDS402DriveStatus.SwitchedOn
        AND NOT stDS402Drive.stDS402DriveStatus.OperationEnabled
        AND stDS402Drive.stDS402DriveStatus.Fault
        AND stDS402Drive.stDS402DriveStatus.VoltageEnabled
        AND NOT stDS402Drive.stDS402DriveStatus.QuickStopActive
        AND NOT stDS402Drive.stDS402DriveStatus.SwitchOnDisabled
    THEN
        bOperational := FALSE;
        bFault := TRUE;
        // (Optionally add fault reset here)

    ELSE
        bOperational := FALSE;
        bFault := FALSE;
    END_IF
END_IF
// wait for parameter init done at startup to read potential error from drive
stMotionStage.bError := bFault AND  stMotionStage.bAxisParamsInit;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="StepMove" Id="{74869c9c-654c-4a5a-9a50-bfad55265981}">
      <Declaration><![CDATA[METHOD  StepMove
VAR_INPUT
    Enable : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[rtStepMove(CLK:=Enable);

CASE eStepState OF

    E_MoveState.IDLING:
        IF rtStepMove.Q THEN
            bStepMoveBusy := TRUE;
            bStepMoveDone := FALSE;
            stDS402Drive.nDS402DriveControl.3 := TRUE;
            eStepState := E_MoveState.INIT;
        END_IF

    E_MoveState.INIT:
        IF stMotionStage.bError THEN
            eStepState := E_MoveState.ERROR;
        ELSE
            stDS402Drive.nDS402DriveControl.4 := TRUE;
            eStepState := E_MoveState.IN_PROGRESS;
        END_IF

    E_MoveState.IN_PROGRESS:
        IF bHalt OR bReset THEN
            bStepMoveAborted := TRUE;
            eStepState := E_MoveState.INTERRUPTED;
        ELSIF stDS402Drive.stDS402DriveStatus.Bit13_OpModeSpecific THEN
            stMotionStage.bError := TRUE;
            eStepState := E_MoveState.ERROR;
        ELSE
            IF stDS402Drive.stDS402DriveStatus.TargetReached THEN
                eStepState := E_MoveState.REACHED;
            END_IF
        END_IF

    E_MoveState.INTERRUPTED:
        IF (stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION ) THEN
            bPositionHold := TRUE;
            tonHoldTime.IN := TRUE;
        END_IF
        // Set bits 0-3 (re-enable if needed)
        stDS402Drive.nDS402DriveControl.4 := FALSE;
        bStepMoveBusy := FALSE;
        eStepState := E_MoveState.IDLING;

    E_MoveState.REACHED:
        bLimOverride := FALSE;
        bStepMoveBusy := FALSE;
        IF (stMotionStage.nEnableMode = E_StageEnableMode.DURING_MOTION ) THEN
            bPositionHold := TRUE;
            tonHoldTime.IN := TRUE;
        END_IF
        bStepMoveDone := TRUE;
        stDS402Drive.nDS402DriveControl.4 := FALSE;
        eStepState := E_MoveState.DONE;

    E_MoveState.DONE:
        IF stMotionStage.bDone THEN
            eStepState := E_MoveState.IDLING;
        END_IF

    E_MoveState.ERROR:
        bStepMoveBusy := FALSE;
        bStepMoveDone := FALSE;
        IF bWrongParameter THEN
            stMotionStage.sCustomErrorMessage := 'Invalid motion Parameters';
            bWrongParameter := FALSE;
            stMotionStage.bError := TRUE;
        END_IF
        IF NOT stMotionStage.bError THEN
            eStepState := E_MoveState.IDLING;
        END_IF
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="WriteParameterNC" Id="{a04e1bd8-55ae-495c-bca4-be27f11603b4}">
      <Declaration><![CDATA[METHOD WriteParameterNC
VAR_INPUT
    Execute:BOOL;
    ParameterNumber : MC_AxisParameter;
    ParameterValue  : LREAL;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*Do not change a moving axis parameter*)
fbMcWriteParameter(
    Axis:=stMotionStage.Axis,
    Execute:=(Execute AND stMotionStage.Axis.Status.NotMoving),
    ParameterNumber:=ParameterNumber,
    Value:=ParameterValue
);
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>